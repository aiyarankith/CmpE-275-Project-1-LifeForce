// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: comm.proto

#ifndef PROTOBUF_comm_2eproto__INCLUDED
#define PROTOBUF_comm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_comm_2eproto();
void protobuf_AssignDesc_comm_2eproto();
void protobuf_ShutdownFile_comm_2eproto();

class NameValueSet;
class NameSpace;
class JobDesc;
class Ping;
class NameSpaceOperation;
class NameSpaceStatus;
class JobOperation;
class JobProposal;
class JobBid;
class JobStatus;
class RoutingPath;
class Header;
class Payload;
class Request;
class Heartbeat;
class Network;
class LeaderElection;
class VotingBallot;
class VotingCast;
class VotingStatus;
class MgmtHeader;
class Management;

enum NameValueSet_NodeType {
  NameValueSet_NodeType_NODE = 1,
  NameValueSet_NodeType_VALUE = 2
};
bool NameValueSet_NodeType_IsValid(int value);
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MIN = NameValueSet_NodeType_NODE;
const NameValueSet_NodeType NameValueSet_NodeType_NodeType_MAX = NameValueSet_NodeType_VALUE;
const int NameValueSet_NodeType_NodeType_ARRAYSIZE = NameValueSet_NodeType_NodeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameValueSet_NodeType_descriptor();
inline const ::std::string& NameValueSet_NodeType_Name(NameValueSet_NodeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameValueSet_NodeType_descriptor(), value);
}
inline bool NameValueSet_NodeType_Parse(
    const ::std::string& name, NameValueSet_NodeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameValueSet_NodeType>(
    NameValueSet_NodeType_descriptor(), name, value);
}
enum JobDesc_JobCode {
  JobDesc_JobCode_JOBUNKNOWN = 1,
  JobDesc_JobCode_JOBRECEIVED = 2,
  JobDesc_JobCode_JOBQUEUED = 3,
  JobDesc_JobCode_JOBRUNNING = 4,
  JobDesc_JobCode_JOBKILLED = 100,
  JobDesc_JobCode_JOBFAILED = 101
};
bool JobDesc_JobCode_IsValid(int value);
const JobDesc_JobCode JobDesc_JobCode_JobCode_MIN = JobDesc_JobCode_JOBUNKNOWN;
const JobDesc_JobCode JobDesc_JobCode_JobCode_MAX = JobDesc_JobCode_JOBFAILED;
const int JobDesc_JobCode_JobCode_ARRAYSIZE = JobDesc_JobCode_JobCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobDesc_JobCode_descriptor();
inline const ::std::string& JobDesc_JobCode_Name(JobDesc_JobCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobDesc_JobCode_descriptor(), value);
}
inline bool JobDesc_JobCode_Parse(
    const ::std::string& name, JobDesc_JobCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobDesc_JobCode>(
    JobDesc_JobCode_descriptor(), name, value);
}
enum NameSpaceOperation_SpaceAction {
  NameSpaceOperation_SpaceAction_ADDSPACE = 1,
  NameSpaceOperation_SpaceAction_UPDATESPACE = 2,
  NameSpaceOperation_SpaceAction_REMOVESPACE = 3,
  NameSpaceOperation_SpaceAction_LISTSPACES = 4
};
bool NameSpaceOperation_SpaceAction_IsValid(int value);
const NameSpaceOperation_SpaceAction NameSpaceOperation_SpaceAction_SpaceAction_MIN = NameSpaceOperation_SpaceAction_ADDSPACE;
const NameSpaceOperation_SpaceAction NameSpaceOperation_SpaceAction_SpaceAction_MAX = NameSpaceOperation_SpaceAction_LISTSPACES;
const int NameSpaceOperation_SpaceAction_SpaceAction_ARRAYSIZE = NameSpaceOperation_SpaceAction_SpaceAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* NameSpaceOperation_SpaceAction_descriptor();
inline const ::std::string& NameSpaceOperation_SpaceAction_Name(NameSpaceOperation_SpaceAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    NameSpaceOperation_SpaceAction_descriptor(), value);
}
inline bool NameSpaceOperation_SpaceAction_Parse(
    const ::std::string& name, NameSpaceOperation_SpaceAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NameSpaceOperation_SpaceAction>(
    NameSpaceOperation_SpaceAction_descriptor(), name, value);
}
enum JobOperation_JobAction {
  JobOperation_JobAction_ADDJOB = 1,
  JobOperation_JobAction_STOPJOB = 2,
  JobOperation_JobAction_REMOVEJOB = 3,
  JobOperation_JobAction_LISTJOBS = 4
};
bool JobOperation_JobAction_IsValid(int value);
const JobOperation_JobAction JobOperation_JobAction_JobAction_MIN = JobOperation_JobAction_ADDJOB;
const JobOperation_JobAction JobOperation_JobAction_JobAction_MAX = JobOperation_JobAction_LISTJOBS;
const int JobOperation_JobAction_JobAction_ARRAYSIZE = JobOperation_JobAction_JobAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* JobOperation_JobAction_descriptor();
inline const ::std::string& JobOperation_JobAction_Name(JobOperation_JobAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    JobOperation_JobAction_descriptor(), value);
}
inline bool JobOperation_JobAction_Parse(
    const ::std::string& name, JobOperation_JobAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JobOperation_JobAction>(
    JobOperation_JobAction_descriptor(), name, value);
}
enum Header_Routing {
  Header_Routing_PING = 2,
  Header_Routing_NAMESPACES = 3,
  Header_Routing_JOBS = 4,
  Header_Routing_REPORTS = 10,
  Header_Routing_MANAGE = 100
};
bool Header_Routing_IsValid(int value);
const Header_Routing Header_Routing_Routing_MIN = Header_Routing_PING;
const Header_Routing Header_Routing_Routing_MAX = Header_Routing_MANAGE;
const int Header_Routing_Routing_ARRAYSIZE = Header_Routing_Routing_MAX + 1;

const ::google::protobuf::EnumDescriptor* Header_Routing_descriptor();
inline const ::std::string& Header_Routing_Name(Header_Routing value) {
  return ::google::protobuf::internal::NameOfEnum(
    Header_Routing_descriptor(), value);
}
inline bool Header_Routing_Parse(
    const ::std::string& name, Header_Routing* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Header_Routing>(
    Header_Routing_descriptor(), name, value);
}
enum Network_NetworkAction {
  Network_NetworkAction_NODEJOIN = 1,
  Network_NetworkAction_NODELEAVE = 2,
  Network_NetworkAction_NODEDEAD = 3,
  Network_NetworkAction_CREATEMAP = 55,
  Network_NetworkAction_ANNOUNCE = 56,
  Network_NetworkAction_SHUTDOWN = 999
};
bool Network_NetworkAction_IsValid(int value);
const Network_NetworkAction Network_NetworkAction_NetworkAction_MIN = Network_NetworkAction_NODEJOIN;
const Network_NetworkAction Network_NetworkAction_NetworkAction_MAX = Network_NetworkAction_SHUTDOWN;
const int Network_NetworkAction_NetworkAction_ARRAYSIZE = Network_NetworkAction_NetworkAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* Network_NetworkAction_descriptor();
inline const ::std::string& Network_NetworkAction_Name(Network_NetworkAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    Network_NetworkAction_descriptor(), value);
}
inline bool Network_NetworkAction_Parse(
    const ::std::string& name, Network_NetworkAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Network_NetworkAction>(
    Network_NetworkAction_descriptor(), name, value);
}
enum LeaderElection_ElectAction {
  LeaderElection_ElectAction_DECLAREELECTION = 1,
  LeaderElection_ElectAction_NOMINATE = 2,
  LeaderElection_ElectAction_ABSTAIN = 3,
  LeaderElection_ElectAction_DECLAREWINNER = 4,
  LeaderElection_ElectAction_DECLAREVOID = 5,
  LeaderElection_ElectAction_WHOISTHELEADER = 6,
  LeaderElection_ElectAction_THELEADERIS = 7
};
bool LeaderElection_ElectAction_IsValid(int value);
const LeaderElection_ElectAction LeaderElection_ElectAction_ElectAction_MIN = LeaderElection_ElectAction_DECLAREELECTION;
const LeaderElection_ElectAction LeaderElection_ElectAction_ElectAction_MAX = LeaderElection_ElectAction_THELEADERIS;
const int LeaderElection_ElectAction_ElectAction_ARRAYSIZE = LeaderElection_ElectAction_ElectAction_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeaderElection_ElectAction_descriptor();
inline const ::std::string& LeaderElection_ElectAction_Name(LeaderElection_ElectAction value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeaderElection_ElectAction_descriptor(), value);
}
inline bool LeaderElection_ElectAction_Parse(
    const ::std::string& name, LeaderElection_ElectAction* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeaderElection_ElectAction>(
    LeaderElection_ElectAction_descriptor(), name, value);
}
enum VotingBallot_BallotType {
  VotingBallot_BallotType_SIMPLEMAJORITY = 1,
  VotingBallot_BallotType_TIMECONSTRAINEDMAJORITY = 2,
  VotingBallot_BallotType_RANKED = 3,
  VotingBallot_BallotType_INSTANTRUNOFF = 4
};
bool VotingBallot_BallotType_IsValid(int value);
const VotingBallot_BallotType VotingBallot_BallotType_BallotType_MIN = VotingBallot_BallotType_SIMPLEMAJORITY;
const VotingBallot_BallotType VotingBallot_BallotType_BallotType_MAX = VotingBallot_BallotType_INSTANTRUNOFF;
const int VotingBallot_BallotType_BallotType_ARRAYSIZE = VotingBallot_BallotType_BallotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* VotingBallot_BallotType_descriptor();
inline const ::std::string& VotingBallot_BallotType_Name(VotingBallot_BallotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    VotingBallot_BallotType_descriptor(), value);
}
inline bool VotingBallot_BallotType_Parse(
    const ::std::string& name, VotingBallot_BallotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VotingBallot_BallotType>(
    VotingBallot_BallotType_descriptor(), name, value);
}
enum VotingStatus_VoteStatus {
  VotingStatus_VoteStatus_BALLOTABANDONED = 1,
  VotingStatus_VoteStatus_BALLOTWINNER = 2
};
bool VotingStatus_VoteStatus_IsValid(int value);
const VotingStatus_VoteStatus VotingStatus_VoteStatus_VoteStatus_MIN = VotingStatus_VoteStatus_BALLOTABANDONED;
const VotingStatus_VoteStatus VotingStatus_VoteStatus_VoteStatus_MAX = VotingStatus_VoteStatus_BALLOTWINNER;
const int VotingStatus_VoteStatus_VoteStatus_ARRAYSIZE = VotingStatus_VoteStatus_VoteStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VotingStatus_VoteStatus_descriptor();
inline const ::std::string& VotingStatus_VoteStatus_Name(VotingStatus_VoteStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VotingStatus_VoteStatus_descriptor(), value);
}
inline bool VotingStatus_VoteStatus_Parse(
    const ::std::string& name, VotingStatus_VoteStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VotingStatus_VoteStatus>(
    VotingStatus_VoteStatus_descriptor(), name, value);
}
enum PokeStatus {
  UKNOWN = 1,
  SUCCESS = 2,
  NOFOUND = 100,
  NOINCOMPLETE = 101,
  NOAUTH = 102,
  NOCONNECTION = 103,
  NOREACHABLE = 104,
  NORESOURCE = 105,
  FAILURE = 199
};
bool PokeStatus_IsValid(int value);
const PokeStatus PokeStatus_MIN = UKNOWN;
const PokeStatus PokeStatus_MAX = FAILURE;
const int PokeStatus_ARRAYSIZE = PokeStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* PokeStatus_descriptor();
inline const ::std::string& PokeStatus_Name(PokeStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    PokeStatus_descriptor(), value);
}
inline bool PokeStatus_Parse(
    const ::std::string& name, PokeStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PokeStatus>(
    PokeStatus_descriptor(), name, value);
}
// ===================================================================

class NameValueSet : public ::google::protobuf::Message {
 public:
  NameValueSet();
  virtual ~NameValueSet();

  NameValueSet(const NameValueSet& from);

  inline NameValueSet& operator=(const NameValueSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameValueSet& default_instance();

  void Swap(NameValueSet* other);

  // implements Message ----------------------------------------------

  NameValueSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameValueSet& from);
  void MergeFrom(const NameValueSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NameValueSet_NodeType NodeType;
  static const NodeType NODE = NameValueSet_NodeType_NODE;
  static const NodeType VALUE = NameValueSet_NodeType_VALUE;
  static inline bool NodeType_IsValid(int value) {
    return NameValueSet_NodeType_IsValid(value);
  }
  static const NodeType NodeType_MIN =
    NameValueSet_NodeType_NodeType_MIN;
  static const NodeType NodeType_MAX =
    NameValueSet_NodeType_NodeType_MAX;
  static const int NodeType_ARRAYSIZE =
    NameValueSet_NodeType_NodeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NodeType_descriptor() {
    return NameValueSet_NodeType_descriptor();
  }
  static inline const ::std::string& NodeType_Name(NodeType value) {
    return NameValueSet_NodeType_Name(value);
  }
  static inline bool NodeType_Parse(const ::std::string& name,
      NodeType* value) {
    return NameValueSet_NodeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NameValueSet.NodeType node_type = 1;
  inline bool has_node_type() const;
  inline void clear_node_type();
  static const int kNodeTypeFieldNumber = 1;
  inline ::NameValueSet_NodeType node_type() const;
  inline void set_node_type(::NameValueSet_NodeType value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated .NameValueSet node = 4;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 4;
  inline const ::NameValueSet& node(int index) const;
  inline ::NameValueSet* mutable_node(int index);
  inline ::NameValueSet* add_node();
  inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
      node() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
      mutable_node();

  // @@protoc_insertion_point(class_scope:NameValueSet)
 private:
  inline void set_has_node_type();
  inline void clear_has_node_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* value_;
  ::google::protobuf::RepeatedPtrField< ::NameValueSet > node_;
  int node_type_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameValueSet* default_instance_;
};
// -------------------------------------------------------------------

class NameSpace : public ::google::protobuf::Message {
 public:
  NameSpace();
  virtual ~NameSpace();

  NameSpace(const NameSpace& from);

  inline NameSpace& operator=(const NameSpace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpace& default_instance();

  void Swap(NameSpace* other);

  // implements Message ----------------------------------------------

  NameSpace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpace& from);
  void MergeFrom(const NameSpace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 ns_id = 2 [default = -1];
  inline bool has_ns_id() const;
  inline void clear_ns_id();
  static const int kNsIdFieldNumber = 2;
  inline ::google::protobuf::int64 ns_id() const;
  inline void set_ns_id(::google::protobuf::int64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional int64 created = 5;
  inline bool has_created() const;
  inline void clear_created();
  static const int kCreatedFieldNumber = 5;
  inline ::google::protobuf::int64 created() const;
  inline void set_created(::google::protobuf::int64 value);

  // optional int64 last_modified = 6;
  inline bool has_last_modified() const;
  inline void clear_last_modified();
  static const int kLastModifiedFieldNumber = 6;
  inline ::google::protobuf::int64 last_modified() const;
  inline void set_last_modified(::google::protobuf::int64 value);

  // optional string owner = 7;
  inline bool has_owner() const;
  inline void clear_owner();
  static const int kOwnerFieldNumber = 7;
  inline const ::std::string& owner() const;
  inline void set_owner(const ::std::string& value);
  inline void set_owner(const char* value);
  inline void set_owner(const char* value, size_t size);
  inline ::std::string* mutable_owner();
  inline ::std::string* release_owner();
  inline void set_allocated_owner(::std::string* owner);

  // optional .NameValueSet properties = 8;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 8;
  inline const ::NameValueSet& properties() const;
  inline ::NameValueSet* mutable_properties();
  inline ::NameValueSet* release_properties();
  inline void set_allocated_properties(::NameValueSet* properties);

  // @@protoc_insertion_point(class_scope:NameSpace)
 private:
  inline void set_has_ns_id();
  inline void clear_has_ns_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_created();
  inline void clear_has_created();
  inline void set_has_last_modified();
  inline void clear_has_last_modified();
  inline void set_has_owner();
  inline void clear_has_owner();
  inline void set_has_properties();
  inline void clear_has_properties();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 ns_id_;
  ::std::string* name_;
  ::std::string* desc_;
  ::google::protobuf::int64 created_;
  ::google::protobuf::int64 last_modified_;
  ::std::string* owner_;
  ::NameValueSet* properties_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpace* default_instance_;
};
// -------------------------------------------------------------------

class JobDesc : public ::google::protobuf::Message {
 public:
  JobDesc();
  virtual ~JobDesc();

  JobDesc(const JobDesc& from);

  inline JobDesc& operator=(const JobDesc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobDesc& default_instance();

  void Swap(JobDesc* other);

  // implements Message ----------------------------------------------

  JobDesc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobDesc& from);
  void MergeFrom(const JobDesc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JobDesc_JobCode JobCode;
  static const JobCode JOBUNKNOWN = JobDesc_JobCode_JOBUNKNOWN;
  static const JobCode JOBRECEIVED = JobDesc_JobCode_JOBRECEIVED;
  static const JobCode JOBQUEUED = JobDesc_JobCode_JOBQUEUED;
  static const JobCode JOBRUNNING = JobDesc_JobCode_JOBRUNNING;
  static const JobCode JOBKILLED = JobDesc_JobCode_JOBKILLED;
  static const JobCode JOBFAILED = JobDesc_JobCode_JOBFAILED;
  static inline bool JobCode_IsValid(int value) {
    return JobDesc_JobCode_IsValid(value);
  }
  static const JobCode JobCode_MIN =
    JobDesc_JobCode_JobCode_MIN;
  static const JobCode JobCode_MAX =
    JobDesc_JobCode_JobCode_MAX;
  static const int JobCode_ARRAYSIZE =
    JobDesc_JobCode_JobCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JobCode_descriptor() {
    return JobDesc_JobCode_descriptor();
  }
  static inline const ::std::string& JobCode_Name(JobCode value) {
    return JobDesc_JobCode_Name(value);
  }
  static inline bool JobCode_Parse(const ::std::string& name,
      JobCode* value) {
    return JobDesc_JobCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required .JobDesc.JobCode status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::JobDesc_JobCode status() const;
  inline void set_status(::JobDesc_JobCode value);

  // optional .NameValueSet options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:JobDesc)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::NameValueSet* options_;
  int status_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobDesc* default_instance_;
};
// -------------------------------------------------------------------

class Ping : public ::google::protobuf::Message {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ping& default_instance();

  void Swap(Ping* other);

  // implements Message ----------------------------------------------

  Ping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);

  // required string tag = 2;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 2;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // @@protoc_insertion_point(class_scope:Ping)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_tag();
  inline void clear_has_tag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tag_;
  ::google::protobuf::int32 number_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Ping* default_instance_;
};
// -------------------------------------------------------------------

class NameSpaceOperation : public ::google::protobuf::Message {
 public:
  NameSpaceOperation();
  virtual ~NameSpaceOperation();

  NameSpaceOperation(const NameSpaceOperation& from);

  inline NameSpaceOperation& operator=(const NameSpaceOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpaceOperation& default_instance();

  void Swap(NameSpaceOperation* other);

  // implements Message ----------------------------------------------

  NameSpaceOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpaceOperation& from);
  void MergeFrom(const NameSpaceOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef NameSpaceOperation_SpaceAction SpaceAction;
  static const SpaceAction ADDSPACE = NameSpaceOperation_SpaceAction_ADDSPACE;
  static const SpaceAction UPDATESPACE = NameSpaceOperation_SpaceAction_UPDATESPACE;
  static const SpaceAction REMOVESPACE = NameSpaceOperation_SpaceAction_REMOVESPACE;
  static const SpaceAction LISTSPACES = NameSpaceOperation_SpaceAction_LISTSPACES;
  static inline bool SpaceAction_IsValid(int value) {
    return NameSpaceOperation_SpaceAction_IsValid(value);
  }
  static const SpaceAction SpaceAction_MIN =
    NameSpaceOperation_SpaceAction_SpaceAction_MIN;
  static const SpaceAction SpaceAction_MAX =
    NameSpaceOperation_SpaceAction_SpaceAction_MAX;
  static const int SpaceAction_ARRAYSIZE =
    NameSpaceOperation_SpaceAction_SpaceAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SpaceAction_descriptor() {
    return NameSpaceOperation_SpaceAction_descriptor();
  }
  static inline const ::std::string& SpaceAction_Name(SpaceAction value) {
    return NameSpaceOperation_SpaceAction_Name(value);
  }
  static inline bool SpaceAction_Parse(const ::std::string& name,
      SpaceAction* value) {
    return NameSpaceOperation_SpaceAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .NameSpaceOperation.SpaceAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::NameSpaceOperation_SpaceAction action() const;
  inline void set_action(::NameSpaceOperation_SpaceAction value);

  // optional int64 ns_id = 2 [default = -1];
  inline bool has_ns_id() const;
  inline void clear_ns_id();
  static const int kNsIdFieldNumber = 2;
  inline ::google::protobuf::int64 ns_id() const;
  inline void set_ns_id(::google::protobuf::int64 value);

  // optional .NameSpace data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::NameSpace& data() const;
  inline ::NameSpace* mutable_data();
  inline ::NameSpace* release_data();
  inline void set_allocated_data(::NameSpace* data);

  // optional .NameValueSet options = 4;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 4;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:NameSpaceOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_ns_id();
  inline void clear_has_ns_id();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 ns_id_;
  ::NameSpace* data_;
  ::NameValueSet* options_;
  int action_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpaceOperation* default_instance_;
};
// -------------------------------------------------------------------

class NameSpaceStatus : public ::google::protobuf::Message {
 public:
  NameSpaceStatus();
  virtual ~NameSpaceStatus();

  NameSpaceStatus(const NameSpaceStatus& from);

  inline NameSpaceStatus& operator=(const NameSpaceStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NameSpaceStatus& default_instance();

  void Swap(NameSpaceStatus* other);

  // implements Message ----------------------------------------------

  NameSpaceStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NameSpaceStatus& from);
  void MergeFrom(const NameSpaceStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .PokeStatus status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::PokeStatus status() const;
  inline void set_status(::PokeStatus value);

  // repeated .NameSpace data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::NameSpace& data(int index) const;
  inline ::NameSpace* mutable_data(int index);
  inline ::NameSpace* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:NameSpaceStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::NameSpace > data_;
  int status_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static NameSpaceStatus* default_instance_;
};
// -------------------------------------------------------------------

class JobOperation : public ::google::protobuf::Message {
 public:
  JobOperation();
  virtual ~JobOperation();

  JobOperation(const JobOperation& from);

  inline JobOperation& operator=(const JobOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobOperation& default_instance();

  void Swap(JobOperation* other);

  // implements Message ----------------------------------------------

  JobOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobOperation& from);
  void MergeFrom(const JobOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef JobOperation_JobAction JobAction;
  static const JobAction ADDJOB = JobOperation_JobAction_ADDJOB;
  static const JobAction STOPJOB = JobOperation_JobAction_STOPJOB;
  static const JobAction REMOVEJOB = JobOperation_JobAction_REMOVEJOB;
  static const JobAction LISTJOBS = JobOperation_JobAction_LISTJOBS;
  static inline bool JobAction_IsValid(int value) {
    return JobOperation_JobAction_IsValid(value);
  }
  static const JobAction JobAction_MIN =
    JobOperation_JobAction_JobAction_MIN;
  static const JobAction JobAction_MAX =
    JobOperation_JobAction_JobAction_MAX;
  static const int JobAction_ARRAYSIZE =
    JobOperation_JobAction_JobAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  JobAction_descriptor() {
    return JobOperation_JobAction_descriptor();
  }
  static inline const ::std::string& JobAction_Name(JobAction value) {
    return JobOperation_JobAction_Name(value);
  }
  static inline bool JobAction_Parse(const ::std::string& name,
      JobAction* value) {
    return JobOperation_JobAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .JobOperation.JobAction action = 1;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 1;
  inline ::JobOperation_JobAction action() const;
  inline void set_action(::JobOperation_JobAction value);

  // optional string job_id = 2;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 2;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // optional .JobDesc data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::JobDesc& data() const;
  inline ::JobDesc* mutable_data();
  inline ::JobDesc* release_data();
  inline void set_allocated_data(::JobDesc* data);

  // @@protoc_insertion_point(class_scope:JobOperation)
 private:
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* job_id_;
  ::JobDesc* data_;
  int action_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobOperation* default_instance_;
};
// -------------------------------------------------------------------

class JobProposal : public ::google::protobuf::Message {
 public:
  JobProposal();
  virtual ~JobProposal();

  JobProposal(const JobProposal& from);

  inline JobProposal& operator=(const JobProposal& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobProposal& default_instance();

  void Swap(JobProposal* other);

  // implements Message ----------------------------------------------

  JobProposal* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobProposal& from);
  void MergeFrom(const JobProposal& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required int32 weight = 4;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 4;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional .NameValueSet options = 5;
  inline bool has_options() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 5;
  inline const ::NameValueSet& options() const;
  inline ::NameValueSet* mutable_options();
  inline ::NameValueSet* release_options();
  inline void set_allocated_options(::NameValueSet* options);

  // @@protoc_insertion_point(class_scope:JobProposal)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_options();
  inline void clear_has_options();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::NameValueSet* options_;
  ::google::protobuf::int32 weight_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobProposal* default_instance_;
};
// -------------------------------------------------------------------

class JobBid : public ::google::protobuf::Message {
 public:
  JobBid();
  virtual ~JobBid();

  JobBid(const JobBid& from);

  inline JobBid& operator=(const JobBid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobBid& default_instance();

  void Swap(JobBid* other);

  // implements Message ----------------------------------------------

  JobBid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobBid& from);
  void MergeFrom(const JobBid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name_space = 1;
  inline bool has_name_space() const;
  inline void clear_name_space();
  static const int kNameSpaceFieldNumber = 1;
  inline const ::std::string& name_space() const;
  inline void set_name_space(const ::std::string& value);
  inline void set_name_space(const char* value);
  inline void set_name_space(const char* value, size_t size);
  inline ::std::string* mutable_name_space();
  inline ::std::string* release_name_space();
  inline void set_allocated_name_space(::std::string* name_space);

  // required int64 owner_id = 2;
  inline bool has_owner_id() const;
  inline void clear_owner_id();
  static const int kOwnerIdFieldNumber = 2;
  inline ::google::protobuf::int64 owner_id() const;
  inline void set_owner_id(::google::protobuf::int64 value);

  // required string job_id = 3;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required int32 bid = 4;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 4;
  inline ::google::protobuf::int32 bid() const;
  inline void set_bid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:JobBid)
 private:
  inline void set_has_name_space();
  inline void clear_has_name_space();
  inline void set_has_owner_id();
  inline void clear_has_owner_id();
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_bid();
  inline void clear_has_bid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_space_;
  ::google::protobuf::int64 owner_id_;
  ::std::string* job_id_;
  ::google::protobuf::int32 bid_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobBid* default_instance_;
};
// -------------------------------------------------------------------

class JobStatus : public ::google::protobuf::Message {
 public:
  JobStatus();
  virtual ~JobStatus();

  JobStatus(const JobStatus& from);

  inline JobStatus& operator=(const JobStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JobStatus& default_instance();

  void Swap(JobStatus* other);

  // implements Message ----------------------------------------------

  JobStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JobStatus& from);
  void MergeFrom(const JobStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string job_id = 1;
  inline bool has_job_id() const;
  inline void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  inline const ::std::string& job_id() const;
  inline void set_job_id(const ::std::string& value);
  inline void set_job_id(const char* value);
  inline void set_job_id(const char* value, size_t size);
  inline ::std::string* mutable_job_id();
  inline ::std::string* release_job_id();
  inline void set_allocated_job_id(::std::string* job_id);

  // required .PokeStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::PokeStatus status() const;
  inline void set_status(::PokeStatus value);

  // required .JobDesc.JobCode job_state = 3;
  inline bool has_job_state() const;
  inline void clear_job_state();
  static const int kJobStateFieldNumber = 3;
  inline ::JobDesc_JobCode job_state() const;
  inline void set_job_state(::JobDesc_JobCode value);

  // repeated .JobDesc data = 4;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::JobDesc& data(int index) const;
  inline ::JobDesc* mutable_data(int index);
  inline ::JobDesc* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::JobDesc >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::JobDesc >*
      mutable_data();

  // @@protoc_insertion_point(class_scope:JobStatus)
 private:
  inline void set_has_job_id();
  inline void clear_has_job_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_job_state();
  inline void clear_has_job_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* job_id_;
  int status_;
  int job_state_;
  ::google::protobuf::RepeatedPtrField< ::JobDesc > data_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static JobStatus* default_instance_;
};
// -------------------------------------------------------------------

class RoutingPath : public ::google::protobuf::Message {
 public:
  RoutingPath();
  virtual ~RoutingPath();

  RoutingPath(const RoutingPath& from);

  inline RoutingPath& operator=(const RoutingPath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingPath& default_instance();

  void Swap(RoutingPath* other);

  // implements Message ----------------------------------------------

  RoutingPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoutingPath& from);
  void MergeFrom(const RoutingPath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 node_id() const;
  inline void set_node_id(::google::protobuf::int32 value);

  // required int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:RoutingPath)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 node_id_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static RoutingPath* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Header_Routing Routing;
  static const Routing PING = Header_Routing_PING;
  static const Routing NAMESPACES = Header_Routing_NAMESPACES;
  static const Routing JOBS = Header_Routing_JOBS;
  static const Routing REPORTS = Header_Routing_REPORTS;
  static const Routing MANAGE = Header_Routing_MANAGE;
  static inline bool Routing_IsValid(int value) {
    return Header_Routing_IsValid(value);
  }
  static const Routing Routing_MIN =
    Header_Routing_Routing_MIN;
  static const Routing Routing_MAX =
    Header_Routing_Routing_MAX;
  static const int Routing_ARRAYSIZE =
    Header_Routing_Routing_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Routing_descriptor() {
    return Header_Routing_descriptor();
  }
  static inline const ::std::string& Routing_Name(Routing value) {
    return Header_Routing_Name(value);
  }
  static inline bool Routing_Parse(const ::std::string& name,
      Routing* value) {
    return Header_Routing_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Header.Routing routing_id = 1;
  inline bool has_routing_id() const;
  inline void clear_routing_id();
  static const int kRoutingIdFieldNumber = 1;
  inline ::Header_Routing routing_id() const;
  inline void set_routing_id(::Header_Routing value);

  // required int32 originator = 2;
  inline bool has_originator() const;
  inline void clear_originator();
  static const int kOriginatorFieldNumber = 2;
  inline ::google::protobuf::int32 originator() const;
  inline void set_originator(::google::protobuf::int32 value);

  // optional string tag = 3;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 3;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const char* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional .PokeStatus reply_code = 5;
  inline bool has_reply_code() const;
  inline void clear_reply_code();
  static const int kReplyCodeFieldNumber = 5;
  inline ::PokeStatus reply_code() const;
  inline void set_reply_code(::PokeStatus value);

  // optional string reply_msg = 6;
  inline bool has_reply_msg() const;
  inline void clear_reply_msg();
  static const int kReplyMsgFieldNumber = 6;
  inline const ::std::string& reply_msg() const;
  inline void set_reply_msg(const ::std::string& value);
  inline void set_reply_msg(const char* value);
  inline void set_reply_msg(const char* value, size_t size);
  inline ::std::string* mutable_reply_msg();
  inline ::std::string* release_reply_msg();
  inline void set_allocated_reply_msg(::std::string* reply_msg);

  // repeated .RoutingPath path = 7;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 7;
  inline const ::RoutingPath& path(int index) const;
  inline ::RoutingPath* mutable_path(int index);
  inline ::RoutingPath* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
      mutable_path();

  // optional int32 toNode = 8;
  inline bool has_tonode() const;
  inline void clear_tonode();
  static const int kToNodeFieldNumber = 8;
  inline ::google::protobuf::int32 tonode() const;
  inline void set_tonode(::google::protobuf::int32 value);

  // repeated .NameValueSet options = 9;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 9;
  inline const ::NameValueSet& options(int index) const;
  inline ::NameValueSet* mutable_options(int index);
  inline ::NameValueSet* add_options();
  inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
      options() const;
  inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
      mutable_options();

  // @@protoc_insertion_point(class_scope:Header)
 private:
  inline void set_has_routing_id();
  inline void clear_has_routing_id();
  inline void set_has_originator();
  inline void clear_has_originator();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_reply_code();
  inline void clear_has_reply_code();
  inline void set_has_reply_msg();
  inline void clear_has_reply_msg();
  inline void set_has_tonode();
  inline void clear_has_tonode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int routing_id_;
  ::google::protobuf::int32 originator_;
  ::std::string* tag_;
  ::google::protobuf::int64 time_;
  ::std::string* reply_msg_;
  int reply_code_;
  ::google::protobuf::int32 tonode_;
  ::google::protobuf::RepeatedPtrField< ::RoutingPath > path_;
  ::google::protobuf::RepeatedPtrField< ::NameValueSet > options_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Payload : public ::google::protobuf::Message {
 public:
  Payload();
  virtual ~Payload();

  Payload(const Payload& from);

  inline Payload& operator=(const Payload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Payload& default_instance();

  void Swap(Payload* other);

  // implements Message ----------------------------------------------

  Payload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Payload& from);
  void MergeFrom(const Payload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Ping ping = 1;
  inline bool has_ping() const;
  inline void clear_ping();
  static const int kPingFieldNumber = 1;
  inline const ::Ping& ping() const;
  inline ::Ping* mutable_ping();
  inline ::Ping* release_ping();
  inline void set_allocated_ping(::Ping* ping);

  // optional .NameSpaceOperation space_op = 2;
  inline bool has_space_op() const;
  inline void clear_space_op();
  static const int kSpaceOpFieldNumber = 2;
  inline const ::NameSpaceOperation& space_op() const;
  inline ::NameSpaceOperation* mutable_space_op();
  inline ::NameSpaceOperation* release_space_op();
  inline void set_allocated_space_op(::NameSpaceOperation* space_op);

  // optional .JobOperation job_op = 3;
  inline bool has_job_op() const;
  inline void clear_job_op();
  static const int kJobOpFieldNumber = 3;
  inline const ::JobOperation& job_op() const;
  inline ::JobOperation* mutable_job_op();
  inline ::JobOperation* release_job_op();
  inline void set_allocated_job_op(::JobOperation* job_op);

  // optional .JobStatus job_status = 13;
  inline bool has_job_status() const;
  inline void clear_job_status();
  static const int kJobStatusFieldNumber = 13;
  inline const ::JobStatus& job_status() const;
  inline ::JobStatus* mutable_job_status();
  inline ::JobStatus* release_job_status();
  inline void set_allocated_job_status(::JobStatus* job_status);

  // optional .NameSpaceStatus space_status = 12;
  inline bool has_space_status() const;
  inline void clear_space_status();
  static const int kSpaceStatusFieldNumber = 12;
  inline const ::NameSpaceStatus& space_status() const;
  inline ::NameSpaceStatus* mutable_space_status();
  inline ::NameSpaceStatus* release_space_status();
  inline void set_allocated_space_status(::NameSpaceStatus* space_status);

  // @@protoc_insertion_point(class_scope:Payload)
 private:
  inline void set_has_ping();
  inline void clear_has_ping();
  inline void set_has_space_op();
  inline void clear_has_space_op();
  inline void set_has_job_op();
  inline void clear_has_job_op();
  inline void set_has_job_status();
  inline void clear_has_job_status();
  inline void set_has_space_status();
  inline void clear_has_space_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Ping* ping_;
  ::NameSpaceOperation* space_op_;
  ::JobOperation* job_op_;
  ::JobStatus* job_status_;
  ::NameSpaceStatus* space_status_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Payload* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::Header& header() const;
  inline ::Header* mutable_header();
  inline ::Header* release_header();
  inline void set_allocated_header(::Header* header);

  // required .Payload body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::Payload& body() const;
  inline ::Payload* mutable_body();
  inline ::Payload* release_body();
  inline void set_allocated_body(::Payload* body);

  // @@protoc_insertion_point(class_scope:Request)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Header* header_;
  ::Payload* body_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Heartbeat : public ::google::protobuf::Message {
 public:
  Heartbeat();
  virtual ~Heartbeat();

  Heartbeat(const Heartbeat& from);

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Heartbeat& default_instance();

  void Swap(Heartbeat* other);

  // implements Message ----------------------------------------------

  Heartbeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Heartbeat& from);
  void MergeFrom(const Heartbeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time_ref = 2;
  inline bool has_time_ref() const;
  inline void clear_time_ref();
  static const int kTimeRefFieldNumber = 2;
  inline ::google::protobuf::int64 time_ref() const;
  inline void set_time_ref(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:
  inline void set_has_time_ref();
  inline void clear_has_time_ref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_ref_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Heartbeat* default_instance_;
};
// -------------------------------------------------------------------

class Network : public ::google::protobuf::Message {
 public:
  Network();
  virtual ~Network();

  Network(const Network& from);

  inline Network& operator=(const Network& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Network& default_instance();

  void Swap(Network* other);

  // implements Message ----------------------------------------------

  Network* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Network& from);
  void MergeFrom(const Network& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Network_NetworkAction NetworkAction;
  static const NetworkAction NODEJOIN = Network_NetworkAction_NODEJOIN;
  static const NetworkAction NODELEAVE = Network_NetworkAction_NODELEAVE;
  static const NetworkAction NODEDEAD = Network_NetworkAction_NODEDEAD;
  static const NetworkAction CREATEMAP = Network_NetworkAction_CREATEMAP;
  static const NetworkAction ANNOUNCE = Network_NetworkAction_ANNOUNCE;
  static const NetworkAction SHUTDOWN = Network_NetworkAction_SHUTDOWN;
  static inline bool NetworkAction_IsValid(int value) {
    return Network_NetworkAction_IsValid(value);
  }
  static const NetworkAction NetworkAction_MIN =
    Network_NetworkAction_NetworkAction_MIN;
  static const NetworkAction NetworkAction_MAX =
    Network_NetworkAction_NetworkAction_MAX;
  static const int NetworkAction_ARRAYSIZE =
    Network_NetworkAction_NetworkAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  NetworkAction_descriptor() {
    return Network_NetworkAction_descriptor();
  }
  static inline const ::std::string& NetworkAction_Name(NetworkAction value) {
    return Network_NetworkAction_Name(value);
  }
  static inline bool NetworkAction_Parse(const ::std::string& name,
      NetworkAction* value) {
    return Network_NetworkAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 from_node_id = 1;
  inline bool has_from_node_id() const;
  inline void clear_from_node_id();
  static const int kFromNodeIdFieldNumber = 1;
  inline ::google::protobuf::int32 from_node_id() const;
  inline void set_from_node_id(::google::protobuf::int32 value);

  // required int32 to_node_id = 2;
  inline bool has_to_node_id() const;
  inline void clear_to_node_id();
  static const int kToNodeIdFieldNumber = 2;
  inline ::google::protobuf::int32 to_node_id() const;
  inline void set_to_node_id(::google::protobuf::int32 value);

  // required .Network.NetworkAction action = 3;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 3;
  inline ::Network_NetworkAction action() const;
  inline void set_action(::Network_NetworkAction value);

  // @@protoc_insertion_point(class_scope:Network)
 private:
  inline void set_has_from_node_id();
  inline void clear_has_from_node_id();
  inline void set_has_to_node_id();
  inline void clear_has_to_node_id();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 from_node_id_;
  ::google::protobuf::int32 to_node_id_;
  int action_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Network* default_instance_;
};
// -------------------------------------------------------------------

class LeaderElection : public ::google::protobuf::Message {
 public:
  LeaderElection();
  virtual ~LeaderElection();

  LeaderElection(const LeaderElection& from);

  inline LeaderElection& operator=(const LeaderElection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LeaderElection& default_instance();

  void Swap(LeaderElection* other);

  // implements Message ----------------------------------------------

  LeaderElection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LeaderElection& from);
  void MergeFrom(const LeaderElection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LeaderElection_ElectAction ElectAction;
  static const ElectAction DECLAREELECTION = LeaderElection_ElectAction_DECLAREELECTION;
  static const ElectAction NOMINATE = LeaderElection_ElectAction_NOMINATE;
  static const ElectAction ABSTAIN = LeaderElection_ElectAction_ABSTAIN;
  static const ElectAction DECLAREWINNER = LeaderElection_ElectAction_DECLAREWINNER;
  static const ElectAction DECLAREVOID = LeaderElection_ElectAction_DECLAREVOID;
  static const ElectAction WHOISTHELEADER = LeaderElection_ElectAction_WHOISTHELEADER;
  static const ElectAction THELEADERIS = LeaderElection_ElectAction_THELEADERIS;
  static inline bool ElectAction_IsValid(int value) {
    return LeaderElection_ElectAction_IsValid(value);
  }
  static const ElectAction ElectAction_MIN =
    LeaderElection_ElectAction_ElectAction_MIN;
  static const ElectAction ElectAction_MAX =
    LeaderElection_ElectAction_ElectAction_MAX;
  static const int ElectAction_ARRAYSIZE =
    LeaderElection_ElectAction_ElectAction_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ElectAction_descriptor() {
    return LeaderElection_ElectAction_descriptor();
  }
  static inline const ::std::string& ElectAction_Name(ElectAction value) {
    return LeaderElection_ElectAction_Name(value);
  }
  static inline bool ElectAction_Parse(const ::std::string& name,
      ElectAction* value) {
    return LeaderElection_ElectAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string elect_id = 2;
  inline bool has_elect_id() const;
  inline void clear_elect_id();
  static const int kElectIdFieldNumber = 2;
  inline const ::std::string& elect_id() const;
  inline void set_elect_id(const ::std::string& value);
  inline void set_elect_id(const char* value);
  inline void set_elect_id(const char* value, size_t size);
  inline ::std::string* mutable_elect_id();
  inline ::std::string* release_elect_id();
  inline void set_allocated_elect_id(::std::string* elect_id);

  // required int32 candidate_id = 3;
  inline bool has_candidate_id() const;
  inline void clear_candidate_id();
  static const int kCandidateIdFieldNumber = 3;
  inline ::google::protobuf::int32 candidate_id() const;
  inline void set_candidate_id(::google::protobuf::int32 value);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required .LeaderElection.ElectAction action = 5;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 5;
  inline ::LeaderElection_ElectAction action() const;
  inline void set_action(::LeaderElection_ElectAction value);

  // optional int64 expires = 6 [default = -1];
  inline bool has_expires() const;
  inline void clear_expires();
  static const int kExpiresFieldNumber = 6;
  inline ::google::protobuf::int64 expires() const;
  inline void set_expires(::google::protobuf::int64 value);

  // optional int32 hops = 7 [default = -1];
  inline bool has_hops() const;
  inline void clear_hops();
  static const int kHopsFieldNumber = 7;
  inline ::google::protobuf::int32 hops() const;
  inline void set_hops(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LeaderElection)
 private:
  inline void set_has_elect_id();
  inline void clear_has_elect_id();
  inline void set_has_candidate_id();
  inline void clear_has_candidate_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_expires();
  inline void clear_has_expires();
  inline void set_has_hops();
  inline void clear_has_hops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* elect_id_;
  ::std::string* desc_;
  ::google::protobuf::int32 candidate_id_;
  int action_;
  ::google::protobuf::int64 expires_;
  ::google::protobuf::int32 hops_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static LeaderElection* default_instance_;
};
// -------------------------------------------------------------------

class VotingBallot : public ::google::protobuf::Message {
 public:
  VotingBallot();
  virtual ~VotingBallot();

  VotingBallot(const VotingBallot& from);

  inline VotingBallot& operator=(const VotingBallot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VotingBallot& default_instance();

  void Swap(VotingBallot* other);

  // implements Message ----------------------------------------------

  VotingBallot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VotingBallot& from);
  void MergeFrom(const VotingBallot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VotingBallot_BallotType BallotType;
  static const BallotType SIMPLEMAJORITY = VotingBallot_BallotType_SIMPLEMAJORITY;
  static const BallotType TIMECONSTRAINEDMAJORITY = VotingBallot_BallotType_TIMECONSTRAINEDMAJORITY;
  static const BallotType RANKED = VotingBallot_BallotType_RANKED;
  static const BallotType INSTANTRUNOFF = VotingBallot_BallotType_INSTANTRUNOFF;
  static inline bool BallotType_IsValid(int value) {
    return VotingBallot_BallotType_IsValid(value);
  }
  static const BallotType BallotType_MIN =
    VotingBallot_BallotType_BallotType_MIN;
  static const BallotType BallotType_MAX =
    VotingBallot_BallotType_BallotType_MAX;
  static const int BallotType_ARRAYSIZE =
    VotingBallot_BallotType_BallotType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BallotType_descriptor() {
    return VotingBallot_BallotType_descriptor();
  }
  static inline const ::std::string& BallotType_Name(BallotType value) {
    return VotingBallot_BallotType_Name(value);
  }
  static inline bool BallotType_Parse(const ::std::string& name,
      BallotType* value) {
    return VotingBallot_BallotType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ballot_id = 1;
  inline bool has_ballot_id() const;
  inline void clear_ballot_id();
  static const int kBallotIdFieldNumber = 1;
  inline const ::std::string& ballot_id() const;
  inline void set_ballot_id(const ::std::string& value);
  inline void set_ballot_id(const char* value);
  inline void set_ballot_id(const char* value, size_t size);
  inline ::std::string* mutable_ballot_id();
  inline ::std::string* release_ballot_id();
  inline void set_allocated_ballot_id(::std::string* ballot_id);

  // required string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required .VotingBallot.BallotType ballot_format = 3;
  inline bool has_ballot_format() const;
  inline void clear_ballot_format();
  static const int kBallotFormatFieldNumber = 3;
  inline ::VotingBallot_BallotType ballot_format() const;
  inline void set_ballot_format(::VotingBallot_BallotType value);

  // optional int64 expires_sec = 6;
  inline bool has_expires_sec() const;
  inline void clear_expires_sec();
  static const int kExpiresSecFieldNumber = 6;
  inline ::google::protobuf::int64 expires_sec() const;
  inline void set_expires_sec(::google::protobuf::int64 value);

  // optional int32 margin_to_win = 7;
  inline bool has_margin_to_win() const;
  inline void clear_margin_to_win();
  static const int kMarginToWinFieldNumber = 7;
  inline ::google::protobuf::int32 margin_to_win() const;
  inline void set_margin_to_win(::google::protobuf::int32 value);

  // optional int32 max_hops = 8 [default = -1];
  inline bool has_max_hops() const;
  inline void clear_max_hops();
  static const int kMaxHopsFieldNumber = 8;
  inline ::google::protobuf::int32 max_hops() const;
  inline void set_max_hops(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VotingBallot)
 private:
  inline void set_has_ballot_id();
  inline void clear_has_ballot_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_ballot_format();
  inline void clear_has_ballot_format();
  inline void set_has_expires_sec();
  inline void clear_has_expires_sec();
  inline void set_has_margin_to_win();
  inline void clear_has_margin_to_win();
  inline void set_has_max_hops();
  inline void clear_has_max_hops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ballot_id_;
  ::std::string* desc_;
  ::google::protobuf::int64 expires_sec_;
  int ballot_format_;
  ::google::protobuf::int32 margin_to_win_;
  ::google::protobuf::int32 max_hops_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static VotingBallot* default_instance_;
};
// -------------------------------------------------------------------

class VotingCast : public ::google::protobuf::Message {
 public:
  VotingCast();
  virtual ~VotingCast();

  VotingCast(const VotingCast& from);

  inline VotingCast& operator=(const VotingCast& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VotingCast& default_instance();

  void Swap(VotingCast* other);

  // implements Message ----------------------------------------------

  VotingCast* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VotingCast& from);
  void MergeFrom(const VotingCast& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string voter = 1;
  inline bool has_voter() const;
  inline void clear_voter();
  static const int kVoterFieldNumber = 1;
  inline const ::std::string& voter() const;
  inline void set_voter(const ::std::string& value);
  inline void set_voter(const char* value);
  inline void set_voter(const char* value, size_t size);
  inline ::std::string* mutable_voter();
  inline ::std::string* release_voter();
  inline void set_allocated_voter(::std::string* voter);

  // required string ballot_id = 2;
  inline bool has_ballot_id() const;
  inline void clear_ballot_id();
  static const int kBallotIdFieldNumber = 2;
  inline const ::std::string& ballot_id() const;
  inline void set_ballot_id(const ::std::string& value);
  inline void set_ballot_id(const char* value);
  inline void set_ballot_id(const char* value, size_t size);
  inline ::std::string* mutable_ballot_id();
  inline ::std::string* release_ballot_id();
  inline void set_allocated_ballot_id(::std::string* ballot_id);

  // optional int32 candidate = 10;
  inline bool has_candidate() const;
  inline void clear_candidate();
  static const int kCandidateFieldNumber = 10;
  inline ::google::protobuf::int32 candidate() const;
  inline void set_candidate(::google::protobuf::int32 value);

  // optional int32 rank = 11;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 11;
  inline ::google::protobuf::int32 rank() const;
  inline void set_rank(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VotingCast)
 private:
  inline void set_has_voter();
  inline void clear_has_voter();
  inline void set_has_ballot_id();
  inline void clear_has_ballot_id();
  inline void set_has_candidate();
  inline void clear_has_candidate();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* voter_;
  ::std::string* ballot_id_;
  ::google::protobuf::int32 candidate_;
  ::google::protobuf::int32 rank_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static VotingCast* default_instance_;
};
// -------------------------------------------------------------------

class VotingStatus : public ::google::protobuf::Message {
 public:
  VotingStatus();
  virtual ~VotingStatus();

  VotingStatus(const VotingStatus& from);

  inline VotingStatus& operator=(const VotingStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VotingStatus& default_instance();

  void Swap(VotingStatus* other);

  // implements Message ----------------------------------------------

  VotingStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VotingStatus& from);
  void MergeFrom(const VotingStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef VotingStatus_VoteStatus VoteStatus;
  static const VoteStatus BALLOTABANDONED = VotingStatus_VoteStatus_BALLOTABANDONED;
  static const VoteStatus BALLOTWINNER = VotingStatus_VoteStatus_BALLOTWINNER;
  static inline bool VoteStatus_IsValid(int value) {
    return VotingStatus_VoteStatus_IsValid(value);
  }
  static const VoteStatus VoteStatus_MIN =
    VotingStatus_VoteStatus_VoteStatus_MIN;
  static const VoteStatus VoteStatus_MAX =
    VotingStatus_VoteStatus_VoteStatus_MAX;
  static const int VoteStatus_ARRAYSIZE =
    VotingStatus_VoteStatus_VoteStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VoteStatus_descriptor() {
    return VotingStatus_VoteStatus_descriptor();
  }
  static inline const ::std::string& VoteStatus_Name(VoteStatus value) {
    return VotingStatus_VoteStatus_Name(value);
  }
  static inline bool VoteStatus_Parse(const ::std::string& name,
      VoteStatus* value) {
    return VotingStatus_VoteStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string ballot_id = 1;
  inline bool has_ballot_id() const;
  inline void clear_ballot_id();
  static const int kBallotIdFieldNumber = 1;
  inline const ::std::string& ballot_id() const;
  inline void set_ballot_id(const ::std::string& value);
  inline void set_ballot_id(const char* value);
  inline void set_ballot_id(const char* value, size_t size);
  inline ::std::string* mutable_ballot_id();
  inline ::std::string* release_ballot_id();
  inline void set_allocated_ballot_id(::std::string* ballot_id);

  // required .VotingStatus.VoteStatus status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::VotingStatus_VoteStatus status() const;
  inline void set_status(::VotingStatus_VoteStatus value);

  // optional int32 winner = 3;
  inline bool has_winner() const;
  inline void clear_winner();
  static const int kWinnerFieldNumber = 3;
  inline ::google::protobuf::int32 winner() const;
  inline void set_winner(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:VotingStatus)
 private:
  inline void set_has_ballot_id();
  inline void clear_has_ballot_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_winner();
  inline void clear_has_winner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* ballot_id_;
  int status_;
  ::google::protobuf::int32 winner_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static VotingStatus* default_instance_;
};
// -------------------------------------------------------------------

class MgmtHeader : public ::google::protobuf::Message {
 public:
  MgmtHeader();
  virtual ~MgmtHeader();

  MgmtHeader(const MgmtHeader& from);

  inline MgmtHeader& operator=(const MgmtHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MgmtHeader& default_instance();

  void Swap(MgmtHeader* other);

  // implements Message ----------------------------------------------

  MgmtHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MgmtHeader& from);
  void MergeFrom(const MgmtHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 originator = 2;
  inline bool has_originator() const;
  inline void clear_originator();
  static const int kOriginatorFieldNumber = 2;
  inline ::google::protobuf::int32 originator() const;
  inline void set_originator(::google::protobuf::int32 value);

  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .RoutingPath path = 7;
  inline int path_size() const;
  inline void clear_path();
  static const int kPathFieldNumber = 7;
  inline const ::RoutingPath& path(int index) const;
  inline ::RoutingPath* mutable_path(int index);
  inline ::RoutingPath* add_path();
  inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
      path() const;
  inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
      mutable_path();

  // optional int32 toNode = 8;
  inline bool has_tonode() const;
  inline void clear_tonode();
  static const int kToNodeFieldNumber = 8;
  inline ::google::protobuf::int32 tonode() const;
  inline void set_tonode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MgmtHeader)
 private:
  inline void set_has_originator();
  inline void clear_has_originator();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_tonode();
  inline void clear_has_tonode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 originator_;
  ::google::protobuf::int32 tonode_;
  ::google::protobuf::RepeatedPtrField< ::RoutingPath > path_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static MgmtHeader* default_instance_;
};
// -------------------------------------------------------------------

class Management : public ::google::protobuf::Message {
 public:
  Management();
  virtual ~Management();

  Management(const Management& from);

  inline Management& operator=(const Management& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Management& default_instance();

  void Swap(Management* other);

  // implements Message ----------------------------------------------

  Management* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Management& from);
  void MergeFrom(const Management& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .MgmtHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::MgmtHeader& header() const;
  inline ::MgmtHeader* mutable_header();
  inline ::MgmtHeader* release_header();
  inline void set_allocated_header(::MgmtHeader* header);

  // optional .Network graph = 2;
  inline bool has_graph() const;
  inline void clear_graph();
  static const int kGraphFieldNumber = 2;
  inline const ::Network& graph() const;
  inline ::Network* mutable_graph();
  inline ::Network* release_graph();
  inline void set_allocated_graph(::Network* graph);

  // optional .Heartbeat beat = 3;
  inline bool has_beat() const;
  inline void clear_beat();
  static const int kBeatFieldNumber = 3;
  inline const ::Heartbeat& beat() const;
  inline ::Heartbeat* mutable_beat();
  inline ::Heartbeat* release_beat();
  inline void set_allocated_beat(::Heartbeat* beat);

  // optional .LeaderElection election = 4;
  inline bool has_election() const;
  inline void clear_election();
  static const int kElectionFieldNumber = 4;
  inline const ::LeaderElection& election() const;
  inline ::LeaderElection* mutable_election();
  inline ::LeaderElection* release_election();
  inline void set_allocated_election(::LeaderElection* election);

  // optional .JobProposal job_propose = 5;
  inline bool has_job_propose() const;
  inline void clear_job_propose();
  static const int kJobProposeFieldNumber = 5;
  inline const ::JobProposal& job_propose() const;
  inline ::JobProposal* mutable_job_propose();
  inline ::JobProposal* release_job_propose();
  inline void set_allocated_job_propose(::JobProposal* job_propose);

  // optional .JobBid job_bid = 6;
  inline bool has_job_bid() const;
  inline void clear_job_bid();
  static const int kJobBidFieldNumber = 6;
  inline const ::JobBid& job_bid() const;
  inline ::JobBid* mutable_job_bid();
  inline ::JobBid* release_job_bid();
  inline void set_allocated_job_bid(::JobBid* job_bid);

  // optional .VotingBallot vote_declare = 7;
  inline bool has_vote_declare() const;
  inline void clear_vote_declare();
  static const int kVoteDeclareFieldNumber = 7;
  inline const ::VotingBallot& vote_declare() const;
  inline ::VotingBallot* mutable_vote_declare();
  inline ::VotingBallot* release_vote_declare();
  inline void set_allocated_vote_declare(::VotingBallot* vote_declare);

  // optional .VotingCast vote_cast = 8;
  inline bool has_vote_cast() const;
  inline void clear_vote_cast();
  static const int kVoteCastFieldNumber = 8;
  inline const ::VotingCast& vote_cast() const;
  inline ::VotingCast* mutable_vote_cast();
  inline ::VotingCast* release_vote_cast();
  inline void set_allocated_vote_cast(::VotingCast* vote_cast);

  // optional .VotingStatus vote_status = 9;
  inline bool has_vote_status() const;
  inline void clear_vote_status();
  static const int kVoteStatusFieldNumber = 9;
  inline const ::VotingStatus& vote_status() const;
  inline ::VotingStatus* mutable_vote_status();
  inline ::VotingStatus* release_vote_status();
  inline void set_allocated_vote_status(::VotingStatus* vote_status);

  // @@protoc_insertion_point(class_scope:Management)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_graph();
  inline void clear_has_graph();
  inline void set_has_beat();
  inline void clear_has_beat();
  inline void set_has_election();
  inline void clear_has_election();
  inline void set_has_job_propose();
  inline void clear_has_job_propose();
  inline void set_has_job_bid();
  inline void clear_has_job_bid();
  inline void set_has_vote_declare();
  inline void clear_has_vote_declare();
  inline void set_has_vote_cast();
  inline void clear_has_vote_cast();
  inline void set_has_vote_status();
  inline void clear_has_vote_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::MgmtHeader* header_;
  ::Network* graph_;
  ::Heartbeat* beat_;
  ::LeaderElection* election_;
  ::JobProposal* job_propose_;
  ::JobBid* job_bid_;
  ::VotingBallot* vote_declare_;
  ::VotingCast* vote_cast_;
  ::VotingStatus* vote_status_;
  friend void  protobuf_AddDesc_comm_2eproto();
  friend void protobuf_AssignDesc_comm_2eproto();
  friend void protobuf_ShutdownFile_comm_2eproto();

  void InitAsDefaultInstance();
  static Management* default_instance_;
};
// ===================================================================


// ===================================================================

// NameValueSet

// required .NameValueSet.NodeType node_type = 1;
inline bool NameValueSet::has_node_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameValueSet::set_has_node_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameValueSet::clear_has_node_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameValueSet::clear_node_type() {
  node_type_ = 1;
  clear_has_node_type();
}
inline ::NameValueSet_NodeType NameValueSet::node_type() const {
  // @@protoc_insertion_point(field_get:NameValueSet.node_type)
  return static_cast< ::NameValueSet_NodeType >(node_type_);
}
inline void NameValueSet::set_node_type(::NameValueSet_NodeType value) {
  assert(::NameValueSet_NodeType_IsValid(value));
  set_has_node_type();
  node_type_ = value;
  // @@protoc_insertion_point(field_set:NameValueSet.node_type)
}

// optional string name = 2;
inline bool NameValueSet::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameValueSet::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameValueSet::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameValueSet::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameValueSet::name() const {
  // @@protoc_insertion_point(field_get:NameValueSet.name)
  return *name_;
}
inline void NameValueSet::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:NameValueSet.name)
}
inline void NameValueSet::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:NameValueSet.name)
}
inline void NameValueSet::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NameValueSet.name)
}
inline ::std::string* NameValueSet::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NameValueSet.name)
  return name_;
}
inline ::std::string* NameValueSet::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameValueSet::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NameValueSet.name)
}

// optional string value = 3;
inline bool NameValueSet::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameValueSet::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameValueSet::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameValueSet::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& NameValueSet::value() const {
  // @@protoc_insertion_point(field_get:NameValueSet.value)
  return *value_;
}
inline void NameValueSet::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:NameValueSet.value)
}
inline void NameValueSet::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:NameValueSet.value)
}
inline void NameValueSet::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NameValueSet.value)
}
inline ::std::string* NameValueSet::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NameValueSet.value)
  return value_;
}
inline ::std::string* NameValueSet::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameValueSet::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NameValueSet.value)
}

// repeated .NameValueSet node = 4;
inline int NameValueSet::node_size() const {
  return node_.size();
}
inline void NameValueSet::clear_node() {
  node_.Clear();
}
inline const ::NameValueSet& NameValueSet::node(int index) const {
  // @@protoc_insertion_point(field_get:NameValueSet.node)
  return node_.Get(index);
}
inline ::NameValueSet* NameValueSet::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:NameValueSet.node)
  return node_.Mutable(index);
}
inline ::NameValueSet* NameValueSet::add_node() {
  // @@protoc_insertion_point(field_add:NameValueSet.node)
  return node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
NameValueSet::node() const {
  // @@protoc_insertion_point(field_list:NameValueSet.node)
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
NameValueSet::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:NameValueSet.node)
  return &node_;
}

// -------------------------------------------------------------------

// NameSpace

// required int64 ns_id = 2 [default = -1];
inline bool NameSpace::has_ns_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpace::set_has_ns_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpace::clear_has_ns_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpace::clear_ns_id() {
  ns_id_ = GOOGLE_LONGLONG(-1);
  clear_has_ns_id();
}
inline ::google::protobuf::int64 NameSpace::ns_id() const {
  // @@protoc_insertion_point(field_get:NameSpace.ns_id)
  return ns_id_;
}
inline void NameSpace::set_ns_id(::google::protobuf::int64 value) {
  set_has_ns_id();
  ns_id_ = value;
  // @@protoc_insertion_point(field_set:NameSpace.ns_id)
}

// optional string name = 3;
inline bool NameSpace::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpace::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpace::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpace::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NameSpace::name() const {
  // @@protoc_insertion_point(field_get:NameSpace.name)
  return *name_;
}
inline void NameSpace::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:NameSpace.name)
}
inline void NameSpace::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:NameSpace.name)
}
inline void NameSpace::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NameSpace.name)
}
inline ::std::string* NameSpace::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NameSpace.name)
  return name_;
}
inline ::std::string* NameSpace::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameSpace::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpace.name)
}

// optional string desc = 4;
inline bool NameSpace::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpace::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpace::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpace::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& NameSpace::desc() const {
  // @@protoc_insertion_point(field_get:NameSpace.desc)
  return *desc_;
}
inline void NameSpace::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:NameSpace.desc)
}
inline void NameSpace::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:NameSpace.desc)
}
inline void NameSpace::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NameSpace.desc)
}
inline ::std::string* NameSpace::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NameSpace.desc)
  return desc_;
}
inline ::std::string* NameSpace::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameSpace::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpace.desc)
}

// optional int64 created = 5;
inline bool NameSpace::has_created() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameSpace::set_has_created() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameSpace::clear_has_created() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameSpace::clear_created() {
  created_ = GOOGLE_LONGLONG(0);
  clear_has_created();
}
inline ::google::protobuf::int64 NameSpace::created() const {
  // @@protoc_insertion_point(field_get:NameSpace.created)
  return created_;
}
inline void NameSpace::set_created(::google::protobuf::int64 value) {
  set_has_created();
  created_ = value;
  // @@protoc_insertion_point(field_set:NameSpace.created)
}

// optional int64 last_modified = 6;
inline bool NameSpace::has_last_modified() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NameSpace::set_has_last_modified() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NameSpace::clear_has_last_modified() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NameSpace::clear_last_modified() {
  last_modified_ = GOOGLE_LONGLONG(0);
  clear_has_last_modified();
}
inline ::google::protobuf::int64 NameSpace::last_modified() const {
  // @@protoc_insertion_point(field_get:NameSpace.last_modified)
  return last_modified_;
}
inline void NameSpace::set_last_modified(::google::protobuf::int64 value) {
  set_has_last_modified();
  last_modified_ = value;
  // @@protoc_insertion_point(field_set:NameSpace.last_modified)
}

// optional string owner = 7;
inline bool NameSpace::has_owner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NameSpace::set_has_owner() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NameSpace::clear_has_owner() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NameSpace::clear_owner() {
  if (owner_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_->clear();
  }
  clear_has_owner();
}
inline const ::std::string& NameSpace::owner() const {
  // @@protoc_insertion_point(field_get:NameSpace.owner)
  return *owner_;
}
inline void NameSpace::set_owner(const ::std::string& value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
  // @@protoc_insertion_point(field_set:NameSpace.owner)
}
inline void NameSpace::set_owner(const char* value) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_ = new ::std::string;
  }
  owner_->assign(value);
  // @@protoc_insertion_point(field_set_char:NameSpace.owner)
}
inline void NameSpace::set_owner(const char* value, size_t size) {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_ = new ::std::string;
  }
  owner_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:NameSpace.owner)
}
inline ::std::string* NameSpace::mutable_owner() {
  set_has_owner();
  if (owner_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    owner_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:NameSpace.owner)
  return owner_;
}
inline ::std::string* NameSpace::release_owner() {
  clear_has_owner();
  if (owner_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = owner_;
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NameSpace::set_allocated_owner(::std::string* owner) {
  if (owner_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete owner_;
  }
  if (owner) {
    set_has_owner();
    owner_ = owner;
  } else {
    clear_has_owner();
    owner_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpace.owner)
}

// optional .NameValueSet properties = 8;
inline bool NameSpace::has_properties() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NameSpace::set_has_properties() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NameSpace::clear_has_properties() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NameSpace::clear_properties() {
  if (properties_ != NULL) properties_->::NameValueSet::Clear();
  clear_has_properties();
}
inline const ::NameValueSet& NameSpace::properties() const {
  // @@protoc_insertion_point(field_get:NameSpace.properties)
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::NameValueSet* NameSpace::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::NameValueSet;
  // @@protoc_insertion_point(field_mutable:NameSpace.properties)
  return properties_;
}
inline ::NameValueSet* NameSpace::release_properties() {
  clear_has_properties();
  ::NameValueSet* temp = properties_;
  properties_ = NULL;
  return temp;
}
inline void NameSpace::set_allocated_properties(::NameValueSet* properties) {
  delete properties_;
  properties_ = properties;
  if (properties) {
    set_has_properties();
  } else {
    clear_has_properties();
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpace.properties)
}

// -------------------------------------------------------------------

// JobDesc

// required string name_space = 1;
inline bool JobDesc::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobDesc::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobDesc::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobDesc::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobDesc::name_space() const {
  // @@protoc_insertion_point(field_get:JobDesc.name_space)
  return *name_space_;
}
inline void JobDesc::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set:JobDesc.name_space)
}
inline void JobDesc::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobDesc.name_space)
}
inline void JobDesc::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobDesc.name_space)
}
inline ::std::string* JobDesc::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobDesc.name_space)
  return name_space_;
}
inline ::std::string* JobDesc::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobDesc::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobDesc.name_space)
}

// required int64 owner_id = 2;
inline bool JobDesc::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobDesc::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobDesc::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobDesc::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobDesc::owner_id() const {
  // @@protoc_insertion_point(field_get:JobDesc.owner_id)
  return owner_id_;
}
inline void JobDesc::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:JobDesc.owner_id)
}

// required string job_id = 3;
inline bool JobDesc::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobDesc::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobDesc::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobDesc::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobDesc::job_id() const {
  // @@protoc_insertion_point(field_get:JobDesc.job_id)
  return *job_id_;
}
inline void JobDesc::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set:JobDesc.job_id)
}
inline void JobDesc::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobDesc.job_id)
}
inline void JobDesc::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobDesc.job_id)
}
inline ::std::string* JobDesc::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobDesc.job_id)
  return job_id_;
}
inline ::std::string* JobDesc::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobDesc::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobDesc.job_id)
}

// required .JobDesc.JobCode status = 4;
inline bool JobDesc::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobDesc::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobDesc::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobDesc::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::JobDesc_JobCode JobDesc::status() const {
  // @@protoc_insertion_point(field_get:JobDesc.status)
  return static_cast< ::JobDesc_JobCode >(status_);
}
inline void JobDesc::set_status(::JobDesc_JobCode value) {
  assert(::JobDesc_JobCode_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:JobDesc.status)
}

// optional .NameValueSet options = 5;
inline bool JobDesc::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobDesc::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobDesc::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobDesc::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& JobDesc::options() const {
  // @@protoc_insertion_point(field_get:JobDesc.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* JobDesc::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  // @@protoc_insertion_point(field_mutable:JobDesc.options)
  return options_;
}
inline ::NameValueSet* JobDesc::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void JobDesc::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:JobDesc.options)
}

// -------------------------------------------------------------------

// Ping

// required int32 number = 1;
inline bool Ping::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ping::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ping::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 Ping::number() const {
  // @@protoc_insertion_point(field_get:Ping.number)
  return number_;
}
inline void Ping::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:Ping.number)
}

// required string tag = 2;
inline bool Ping::has_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::set_has_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ping::clear_has_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ping::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Ping::tag() const {
  // @@protoc_insertion_point(field_get:Ping.tag)
  return *tag_;
}
inline void Ping::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:Ping.tag)
}
inline void Ping::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:Ping.tag)
}
inline void Ping::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Ping.tag)
}
inline ::std::string* Ping::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Ping.tag)
  return tag_;
}
inline ::std::string* Ping::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Ping::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Ping.tag)
}

// -------------------------------------------------------------------

// NameSpaceOperation

// required .NameSpaceOperation.SpaceAction action = 1;
inline bool NameSpaceOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpaceOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpaceOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpaceOperation::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::NameSpaceOperation_SpaceAction NameSpaceOperation::action() const {
  // @@protoc_insertion_point(field_get:NameSpaceOperation.action)
  return static_cast< ::NameSpaceOperation_SpaceAction >(action_);
}
inline void NameSpaceOperation::set_action(::NameSpaceOperation_SpaceAction value) {
  assert(::NameSpaceOperation_SpaceAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:NameSpaceOperation.action)
}

// optional int64 ns_id = 2 [default = -1];
inline bool NameSpaceOperation::has_ns_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameSpaceOperation::set_has_ns_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NameSpaceOperation::clear_has_ns_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NameSpaceOperation::clear_ns_id() {
  ns_id_ = GOOGLE_LONGLONG(-1);
  clear_has_ns_id();
}
inline ::google::protobuf::int64 NameSpaceOperation::ns_id() const {
  // @@protoc_insertion_point(field_get:NameSpaceOperation.ns_id)
  return ns_id_;
}
inline void NameSpaceOperation::set_ns_id(::google::protobuf::int64 value) {
  set_has_ns_id();
  ns_id_ = value;
  // @@protoc_insertion_point(field_set:NameSpaceOperation.ns_id)
}

// optional .NameSpace data = 3;
inline bool NameSpaceOperation::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NameSpaceOperation::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NameSpaceOperation::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NameSpaceOperation::clear_data() {
  if (data_ != NULL) data_->::NameSpace::Clear();
  clear_has_data();
}
inline const ::NameSpace& NameSpaceOperation::data() const {
  // @@protoc_insertion_point(field_get:NameSpaceOperation.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::NameSpace* NameSpaceOperation::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::NameSpace;
  // @@protoc_insertion_point(field_mutable:NameSpaceOperation.data)
  return data_;
}
inline ::NameSpace* NameSpaceOperation::release_data() {
  clear_has_data();
  ::NameSpace* temp = data_;
  data_ = NULL;
  return temp;
}
inline void NameSpaceOperation::set_allocated_data(::NameSpace* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpaceOperation.data)
}

// optional .NameValueSet options = 4;
inline bool NameSpaceOperation::has_options() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NameSpaceOperation::set_has_options() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NameSpaceOperation::clear_has_options() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NameSpaceOperation::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& NameSpaceOperation::options() const {
  // @@protoc_insertion_point(field_get:NameSpaceOperation.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* NameSpaceOperation::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  // @@protoc_insertion_point(field_mutable:NameSpaceOperation.options)
  return options_;
}
inline ::NameValueSet* NameSpaceOperation::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void NameSpaceOperation::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:NameSpaceOperation.options)
}

// -------------------------------------------------------------------

// NameSpaceStatus

// required .PokeStatus status = 1;
inline bool NameSpaceStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameSpaceStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NameSpaceStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NameSpaceStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::PokeStatus NameSpaceStatus::status() const {
  // @@protoc_insertion_point(field_get:NameSpaceStatus.status)
  return static_cast< ::PokeStatus >(status_);
}
inline void NameSpaceStatus::set_status(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:NameSpaceStatus.status)
}

// repeated .NameSpace data = 2;
inline int NameSpaceStatus::data_size() const {
  return data_.size();
}
inline void NameSpaceStatus::clear_data() {
  data_.Clear();
}
inline const ::NameSpace& NameSpaceStatus::data(int index) const {
  // @@protoc_insertion_point(field_get:NameSpaceStatus.data)
  return data_.Get(index);
}
inline ::NameSpace* NameSpaceStatus::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:NameSpaceStatus.data)
  return data_.Mutable(index);
}
inline ::NameSpace* NameSpaceStatus::add_data() {
  // @@protoc_insertion_point(field_add:NameSpaceStatus.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameSpace >&
NameSpaceStatus::data() const {
  // @@protoc_insertion_point(field_list:NameSpaceStatus.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameSpace >*
NameSpaceStatus::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:NameSpaceStatus.data)
  return &data_;
}

// -------------------------------------------------------------------

// JobOperation

// required .JobOperation.JobAction action = 1;
inline bool JobOperation::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobOperation::set_has_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobOperation::clear_has_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobOperation::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::JobOperation_JobAction JobOperation::action() const {
  // @@protoc_insertion_point(field_get:JobOperation.action)
  return static_cast< ::JobOperation_JobAction >(action_);
}
inline void JobOperation::set_action(::JobOperation_JobAction value) {
  assert(::JobOperation_JobAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:JobOperation.action)
}

// optional string job_id = 2;
inline bool JobOperation::has_job_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobOperation::set_has_job_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobOperation::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobOperation::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobOperation::job_id() const {
  // @@protoc_insertion_point(field_get:JobOperation.job_id)
  return *job_id_;
}
inline void JobOperation::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set:JobOperation.job_id)
}
inline void JobOperation::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobOperation.job_id)
}
inline void JobOperation::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobOperation.job_id)
}
inline ::std::string* JobOperation::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobOperation.job_id)
  return job_id_;
}
inline ::std::string* JobOperation::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobOperation::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobOperation.job_id)
}

// optional .JobDesc data = 3;
inline bool JobOperation::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobOperation::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobOperation::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobOperation::clear_data() {
  if (data_ != NULL) data_->::JobDesc::Clear();
  clear_has_data();
}
inline const ::JobDesc& JobOperation::data() const {
  // @@protoc_insertion_point(field_get:JobOperation.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::JobDesc* JobOperation::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::JobDesc;
  // @@protoc_insertion_point(field_mutable:JobOperation.data)
  return data_;
}
inline ::JobDesc* JobOperation::release_data() {
  clear_has_data();
  ::JobDesc* temp = data_;
  data_ = NULL;
  return temp;
}
inline void JobOperation::set_allocated_data(::JobDesc* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:JobOperation.data)
}

// -------------------------------------------------------------------

// JobProposal

// required string name_space = 1;
inline bool JobProposal::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobProposal::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobProposal::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobProposal::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobProposal::name_space() const {
  // @@protoc_insertion_point(field_get:JobProposal.name_space)
  return *name_space_;
}
inline void JobProposal::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set:JobProposal.name_space)
}
inline void JobProposal::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobProposal.name_space)
}
inline void JobProposal::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobProposal.name_space)
}
inline ::std::string* JobProposal::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobProposal.name_space)
  return name_space_;
}
inline ::std::string* JobProposal::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobProposal::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobProposal.name_space)
}

// required int64 owner_id = 2;
inline bool JobProposal::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobProposal::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobProposal::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobProposal::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobProposal::owner_id() const {
  // @@protoc_insertion_point(field_get:JobProposal.owner_id)
  return owner_id_;
}
inline void JobProposal::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:JobProposal.owner_id)
}

// required string job_id = 3;
inline bool JobProposal::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobProposal::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobProposal::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobProposal::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobProposal::job_id() const {
  // @@protoc_insertion_point(field_get:JobProposal.job_id)
  return *job_id_;
}
inline void JobProposal::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set:JobProposal.job_id)
}
inline void JobProposal::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobProposal.job_id)
}
inline void JobProposal::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobProposal.job_id)
}
inline ::std::string* JobProposal::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobProposal.job_id)
  return job_id_;
}
inline ::std::string* JobProposal::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobProposal::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobProposal.job_id)
}

// required int32 weight = 4;
inline bool JobProposal::has_weight() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobProposal::set_has_weight() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobProposal::clear_has_weight() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobProposal::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 JobProposal::weight() const {
  // @@protoc_insertion_point(field_get:JobProposal.weight)
  return weight_;
}
inline void JobProposal::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:JobProposal.weight)
}

// optional .NameValueSet options = 5;
inline bool JobProposal::has_options() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JobProposal::set_has_options() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JobProposal::clear_has_options() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JobProposal::clear_options() {
  if (options_ != NULL) options_->::NameValueSet::Clear();
  clear_has_options();
}
inline const ::NameValueSet& JobProposal::options() const {
  // @@protoc_insertion_point(field_get:JobProposal.options)
  return options_ != NULL ? *options_ : *default_instance_->options_;
}
inline ::NameValueSet* JobProposal::mutable_options() {
  set_has_options();
  if (options_ == NULL) options_ = new ::NameValueSet;
  // @@protoc_insertion_point(field_mutable:JobProposal.options)
  return options_;
}
inline ::NameValueSet* JobProposal::release_options() {
  clear_has_options();
  ::NameValueSet* temp = options_;
  options_ = NULL;
  return temp;
}
inline void JobProposal::set_allocated_options(::NameValueSet* options) {
  delete options_;
  options_ = options;
  if (options) {
    set_has_options();
  } else {
    clear_has_options();
  }
  // @@protoc_insertion_point(field_set_allocated:JobProposal.options)
}

// -------------------------------------------------------------------

// JobBid

// required string name_space = 1;
inline bool JobBid::has_name_space() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobBid::set_has_name_space() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobBid::clear_has_name_space() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobBid::clear_name_space() {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_->clear();
  }
  clear_has_name_space();
}
inline const ::std::string& JobBid::name_space() const {
  // @@protoc_insertion_point(field_get:JobBid.name_space)
  return *name_space_;
}
inline void JobBid::set_name_space(const ::std::string& value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set:JobBid.name_space)
}
inline void JobBid::set_name_space(const char* value) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobBid.name_space)
}
inline void JobBid::set_name_space(const char* value, size_t size) {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  name_space_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobBid.name_space)
}
inline ::std::string* JobBid::mutable_name_space() {
  set_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_space_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobBid.name_space)
  return name_space_;
}
inline ::std::string* JobBid::release_name_space() {
  clear_has_name_space();
  if (name_space_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_space_;
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobBid::set_allocated_name_space(::std::string* name_space) {
  if (name_space_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_space_;
  }
  if (name_space) {
    set_has_name_space();
    name_space_ = name_space;
  } else {
    clear_has_name_space();
    name_space_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobBid.name_space)
}

// required int64 owner_id = 2;
inline bool JobBid::has_owner_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobBid::set_has_owner_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobBid::clear_has_owner_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobBid::clear_owner_id() {
  owner_id_ = GOOGLE_LONGLONG(0);
  clear_has_owner_id();
}
inline ::google::protobuf::int64 JobBid::owner_id() const {
  // @@protoc_insertion_point(field_get:JobBid.owner_id)
  return owner_id_;
}
inline void JobBid::set_owner_id(::google::protobuf::int64 value) {
  set_has_owner_id();
  owner_id_ = value;
  // @@protoc_insertion_point(field_set:JobBid.owner_id)
}

// required string job_id = 3;
inline bool JobBid::has_job_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobBid::set_has_job_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobBid::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobBid::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobBid::job_id() const {
  // @@protoc_insertion_point(field_get:JobBid.job_id)
  return *job_id_;
}
inline void JobBid::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set:JobBid.job_id)
}
inline void JobBid::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobBid.job_id)
}
inline void JobBid::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobBid.job_id)
}
inline ::std::string* JobBid::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobBid.job_id)
  return job_id_;
}
inline ::std::string* JobBid::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobBid::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobBid.job_id)
}

// required int32 bid = 4;
inline bool JobBid::has_bid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JobBid::set_has_bid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JobBid::clear_has_bid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JobBid::clear_bid() {
  bid_ = 0;
  clear_has_bid();
}
inline ::google::protobuf::int32 JobBid::bid() const {
  // @@protoc_insertion_point(field_get:JobBid.bid)
  return bid_;
}
inline void JobBid::set_bid(::google::protobuf::int32 value) {
  set_has_bid();
  bid_ = value;
  // @@protoc_insertion_point(field_set:JobBid.bid)
}

// -------------------------------------------------------------------

// JobStatus

// required string job_id = 1;
inline bool JobStatus::has_job_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JobStatus::set_has_job_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JobStatus::clear_has_job_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JobStatus::clear_job_id() {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_->clear();
  }
  clear_has_job_id();
}
inline const ::std::string& JobStatus::job_id() const {
  // @@protoc_insertion_point(field_get:JobStatus.job_id)
  return *job_id_;
}
inline void JobStatus::set_job_id(const ::std::string& value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set:JobStatus.job_id)
}
inline void JobStatus::set_job_id(const char* value) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:JobStatus.job_id)
}
inline void JobStatus::set_job_id(const char* value, size_t size) {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  job_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:JobStatus.job_id)
}
inline ::std::string* JobStatus::mutable_job_id() {
  set_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    job_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:JobStatus.job_id)
  return job_id_;
}
inline ::std::string* JobStatus::release_job_id() {
  clear_has_job_id();
  if (job_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = job_id_;
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void JobStatus::set_allocated_job_id(::std::string* job_id) {
  if (job_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete job_id_;
  }
  if (job_id) {
    set_has_job_id();
    job_id_ = job_id;
  } else {
    clear_has_job_id();
    job_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:JobStatus.job_id)
}

// required .PokeStatus status = 2;
inline bool JobStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JobStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JobStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JobStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::PokeStatus JobStatus::status() const {
  // @@protoc_insertion_point(field_get:JobStatus.status)
  return static_cast< ::PokeStatus >(status_);
}
inline void JobStatus::set_status(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:JobStatus.status)
}

// required .JobDesc.JobCode job_state = 3;
inline bool JobStatus::has_job_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JobStatus::set_has_job_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JobStatus::clear_has_job_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JobStatus::clear_job_state() {
  job_state_ = 1;
  clear_has_job_state();
}
inline ::JobDesc_JobCode JobStatus::job_state() const {
  // @@protoc_insertion_point(field_get:JobStatus.job_state)
  return static_cast< ::JobDesc_JobCode >(job_state_);
}
inline void JobStatus::set_job_state(::JobDesc_JobCode value) {
  assert(::JobDesc_JobCode_IsValid(value));
  set_has_job_state();
  job_state_ = value;
  // @@protoc_insertion_point(field_set:JobStatus.job_state)
}

// repeated .JobDesc data = 4;
inline int JobStatus::data_size() const {
  return data_.size();
}
inline void JobStatus::clear_data() {
  data_.Clear();
}
inline const ::JobDesc& JobStatus::data(int index) const {
  // @@protoc_insertion_point(field_get:JobStatus.data)
  return data_.Get(index);
}
inline ::JobDesc* JobStatus::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:JobStatus.data)
  return data_.Mutable(index);
}
inline ::JobDesc* JobStatus::add_data() {
  // @@protoc_insertion_point(field_add:JobStatus.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::JobDesc >&
JobStatus::data() const {
  // @@protoc_insertion_point(field_list:JobStatus.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::JobDesc >*
JobStatus::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:JobStatus.data)
  return &data_;
}

// -------------------------------------------------------------------

// RoutingPath

// required int32 node_id = 1;
inline bool RoutingPath::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingPath::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingPath::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingPath::clear_node_id() {
  node_id_ = 0;
  clear_has_node_id();
}
inline ::google::protobuf::int32 RoutingPath::node_id() const {
  // @@protoc_insertion_point(field_get:RoutingPath.node_id)
  return node_id_;
}
inline void RoutingPath::set_node_id(::google::protobuf::int32 value) {
  set_has_node_id();
  node_id_ = value;
  // @@protoc_insertion_point(field_set:RoutingPath.node_id)
}

// required int64 time = 2;
inline bool RoutingPath::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingPath::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingPath::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingPath::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 RoutingPath::time() const {
  // @@protoc_insertion_point(field_get:RoutingPath.time)
  return time_;
}
inline void RoutingPath::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:RoutingPath.time)
}

// -------------------------------------------------------------------

// Header

// required .Header.Routing routing_id = 1;
inline bool Header::has_routing_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_routing_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_routing_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_routing_id() {
  routing_id_ = 2;
  clear_has_routing_id();
}
inline ::Header_Routing Header::routing_id() const {
  // @@protoc_insertion_point(field_get:Header.routing_id)
  return static_cast< ::Header_Routing >(routing_id_);
}
inline void Header::set_routing_id(::Header_Routing value) {
  assert(::Header_Routing_IsValid(value));
  set_has_routing_id();
  routing_id_ = value;
  // @@protoc_insertion_point(field_set:Header.routing_id)
}

// required int32 originator = 2;
inline bool Header::has_originator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_originator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_originator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_originator() {
  originator_ = 0;
  clear_has_originator();
}
inline ::google::protobuf::int32 Header::originator() const {
  // @@protoc_insertion_point(field_get:Header.originator)
  return originator_;
}
inline void Header::set_originator(::google::protobuf::int32 value) {
  set_has_originator();
  originator_ = value;
  // @@protoc_insertion_point(field_set:Header.originator)
}

// optional string tag = 3;
inline bool Header::has_tag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_tag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_tag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_tag() {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Header::tag() const {
  // @@protoc_insertion_point(field_get:Header.tag)
  return *tag_;
}
inline void Header::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set:Header.tag)
}
inline void Header::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
  // @@protoc_insertion_point(field_set_char:Header.tag)
}
inline void Header::set_tag(const char* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Header.tag)
}
inline ::std::string* Header::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tag_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Header.tag)
  return tag_;
}
inline ::std::string* Header::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Header.tag)
}

// optional int64 time = 4;
inline bool Header::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Header::time() const {
  // @@protoc_insertion_point(field_get:Header.time)
  return time_;
}
inline void Header::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:Header.time)
}

// optional .PokeStatus reply_code = 5;
inline bool Header::has_reply_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_reply_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_reply_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_reply_code() {
  reply_code_ = 1;
  clear_has_reply_code();
}
inline ::PokeStatus Header::reply_code() const {
  // @@protoc_insertion_point(field_get:Header.reply_code)
  return static_cast< ::PokeStatus >(reply_code_);
}
inline void Header::set_reply_code(::PokeStatus value) {
  assert(::PokeStatus_IsValid(value));
  set_has_reply_code();
  reply_code_ = value;
  // @@protoc_insertion_point(field_set:Header.reply_code)
}

// optional string reply_msg = 6;
inline bool Header::has_reply_msg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_reply_msg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_reply_msg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_reply_msg() {
  if (reply_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_msg_->clear();
  }
  clear_has_reply_msg();
}
inline const ::std::string& Header::reply_msg() const {
  // @@protoc_insertion_point(field_get:Header.reply_msg)
  return *reply_msg_;
}
inline void Header::set_reply_msg(const ::std::string& value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
  // @@protoc_insertion_point(field_set:Header.reply_msg)
}
inline void Header::set_reply_msg(const char* value) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(value);
  // @@protoc_insertion_point(field_set_char:Header.reply_msg)
}
inline void Header::set_reply_msg(const char* value, size_t size) {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_msg_ = new ::std::string;
  }
  reply_msg_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Header.reply_msg)
}
inline ::std::string* Header::mutable_reply_msg() {
  set_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    reply_msg_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Header.reply_msg)
  return reply_msg_;
}
inline ::std::string* Header::release_reply_msg() {
  clear_has_reply_msg();
  if (reply_msg_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = reply_msg_;
    reply_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Header::set_allocated_reply_msg(::std::string* reply_msg) {
  if (reply_msg_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete reply_msg_;
  }
  if (reply_msg) {
    set_has_reply_msg();
    reply_msg_ = reply_msg;
  } else {
    clear_has_reply_msg();
    reply_msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Header.reply_msg)
}

// repeated .RoutingPath path = 7;
inline int Header::path_size() const {
  return path_.size();
}
inline void Header::clear_path() {
  path_.Clear();
}
inline const ::RoutingPath& Header::path(int index) const {
  // @@protoc_insertion_point(field_get:Header.path)
  return path_.Get(index);
}
inline ::RoutingPath* Header::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:Header.path)
  return path_.Mutable(index);
}
inline ::RoutingPath* Header::add_path() {
  // @@protoc_insertion_point(field_add:Header.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
Header::path() const {
  // @@protoc_insertion_point(field_list:Header.path)
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
Header::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:Header.path)
  return &path_;
}

// optional int32 toNode = 8;
inline bool Header::has_tonode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_tonode() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_tonode() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_tonode() {
  tonode_ = 0;
  clear_has_tonode();
}
inline ::google::protobuf::int32 Header::tonode() const {
  // @@protoc_insertion_point(field_get:Header.toNode)
  return tonode_;
}
inline void Header::set_tonode(::google::protobuf::int32 value) {
  set_has_tonode();
  tonode_ = value;
  // @@protoc_insertion_point(field_set:Header.toNode)
}

// repeated .NameValueSet options = 9;
inline int Header::options_size() const {
  return options_.size();
}
inline void Header::clear_options() {
  options_.Clear();
}
inline const ::NameValueSet& Header::options(int index) const {
  // @@protoc_insertion_point(field_get:Header.options)
  return options_.Get(index);
}
inline ::NameValueSet* Header::mutable_options(int index) {
  // @@protoc_insertion_point(field_mutable:Header.options)
  return options_.Mutable(index);
}
inline ::NameValueSet* Header::add_options() {
  // @@protoc_insertion_point(field_add:Header.options)
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::NameValueSet >&
Header::options() const {
  // @@protoc_insertion_point(field_list:Header.options)
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::NameValueSet >*
Header::mutable_options() {
  // @@protoc_insertion_point(field_mutable_list:Header.options)
  return &options_;
}

// -------------------------------------------------------------------

// Payload

// optional .Ping ping = 1;
inline bool Payload::has_ping() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Payload::set_has_ping() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Payload::clear_has_ping() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Payload::clear_ping() {
  if (ping_ != NULL) ping_->::Ping::Clear();
  clear_has_ping();
}
inline const ::Ping& Payload::ping() const {
  // @@protoc_insertion_point(field_get:Payload.ping)
  return ping_ != NULL ? *ping_ : *default_instance_->ping_;
}
inline ::Ping* Payload::mutable_ping() {
  set_has_ping();
  if (ping_ == NULL) ping_ = new ::Ping;
  // @@protoc_insertion_point(field_mutable:Payload.ping)
  return ping_;
}
inline ::Ping* Payload::release_ping() {
  clear_has_ping();
  ::Ping* temp = ping_;
  ping_ = NULL;
  return temp;
}
inline void Payload::set_allocated_ping(::Ping* ping) {
  delete ping_;
  ping_ = ping;
  if (ping) {
    set_has_ping();
  } else {
    clear_has_ping();
  }
  // @@protoc_insertion_point(field_set_allocated:Payload.ping)
}

// optional .NameSpaceOperation space_op = 2;
inline bool Payload::has_space_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Payload::set_has_space_op() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Payload::clear_has_space_op() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Payload::clear_space_op() {
  if (space_op_ != NULL) space_op_->::NameSpaceOperation::Clear();
  clear_has_space_op();
}
inline const ::NameSpaceOperation& Payload::space_op() const {
  // @@protoc_insertion_point(field_get:Payload.space_op)
  return space_op_ != NULL ? *space_op_ : *default_instance_->space_op_;
}
inline ::NameSpaceOperation* Payload::mutable_space_op() {
  set_has_space_op();
  if (space_op_ == NULL) space_op_ = new ::NameSpaceOperation;
  // @@protoc_insertion_point(field_mutable:Payload.space_op)
  return space_op_;
}
inline ::NameSpaceOperation* Payload::release_space_op() {
  clear_has_space_op();
  ::NameSpaceOperation* temp = space_op_;
  space_op_ = NULL;
  return temp;
}
inline void Payload::set_allocated_space_op(::NameSpaceOperation* space_op) {
  delete space_op_;
  space_op_ = space_op;
  if (space_op) {
    set_has_space_op();
  } else {
    clear_has_space_op();
  }
  // @@protoc_insertion_point(field_set_allocated:Payload.space_op)
}

// optional .JobOperation job_op = 3;
inline bool Payload::has_job_op() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Payload::set_has_job_op() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Payload::clear_has_job_op() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Payload::clear_job_op() {
  if (job_op_ != NULL) job_op_->::JobOperation::Clear();
  clear_has_job_op();
}
inline const ::JobOperation& Payload::job_op() const {
  // @@protoc_insertion_point(field_get:Payload.job_op)
  return job_op_ != NULL ? *job_op_ : *default_instance_->job_op_;
}
inline ::JobOperation* Payload::mutable_job_op() {
  set_has_job_op();
  if (job_op_ == NULL) job_op_ = new ::JobOperation;
  // @@protoc_insertion_point(field_mutable:Payload.job_op)
  return job_op_;
}
inline ::JobOperation* Payload::release_job_op() {
  clear_has_job_op();
  ::JobOperation* temp = job_op_;
  job_op_ = NULL;
  return temp;
}
inline void Payload::set_allocated_job_op(::JobOperation* job_op) {
  delete job_op_;
  job_op_ = job_op;
  if (job_op) {
    set_has_job_op();
  } else {
    clear_has_job_op();
  }
  // @@protoc_insertion_point(field_set_allocated:Payload.job_op)
}

// optional .JobStatus job_status = 13;
inline bool Payload::has_job_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Payload::set_has_job_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Payload::clear_has_job_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Payload::clear_job_status() {
  if (job_status_ != NULL) job_status_->::JobStatus::Clear();
  clear_has_job_status();
}
inline const ::JobStatus& Payload::job_status() const {
  // @@protoc_insertion_point(field_get:Payload.job_status)
  return job_status_ != NULL ? *job_status_ : *default_instance_->job_status_;
}
inline ::JobStatus* Payload::mutable_job_status() {
  set_has_job_status();
  if (job_status_ == NULL) job_status_ = new ::JobStatus;
  // @@protoc_insertion_point(field_mutable:Payload.job_status)
  return job_status_;
}
inline ::JobStatus* Payload::release_job_status() {
  clear_has_job_status();
  ::JobStatus* temp = job_status_;
  job_status_ = NULL;
  return temp;
}
inline void Payload::set_allocated_job_status(::JobStatus* job_status) {
  delete job_status_;
  job_status_ = job_status;
  if (job_status) {
    set_has_job_status();
  } else {
    clear_has_job_status();
  }
  // @@protoc_insertion_point(field_set_allocated:Payload.job_status)
}

// optional .NameSpaceStatus space_status = 12;
inline bool Payload::has_space_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Payload::set_has_space_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Payload::clear_has_space_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Payload::clear_space_status() {
  if (space_status_ != NULL) space_status_->::NameSpaceStatus::Clear();
  clear_has_space_status();
}
inline const ::NameSpaceStatus& Payload::space_status() const {
  // @@protoc_insertion_point(field_get:Payload.space_status)
  return space_status_ != NULL ? *space_status_ : *default_instance_->space_status_;
}
inline ::NameSpaceStatus* Payload::mutable_space_status() {
  set_has_space_status();
  if (space_status_ == NULL) space_status_ = new ::NameSpaceStatus;
  // @@protoc_insertion_point(field_mutable:Payload.space_status)
  return space_status_;
}
inline ::NameSpaceStatus* Payload::release_space_status() {
  clear_has_space_status();
  ::NameSpaceStatus* temp = space_status_;
  space_status_ = NULL;
  return temp;
}
inline void Payload::set_allocated_space_status(::NameSpaceStatus* space_status) {
  delete space_status_;
  space_status_ = space_status;
  if (space_status) {
    set_has_space_status();
  } else {
    clear_has_space_status();
  }
  // @@protoc_insertion_point(field_set_allocated:Payload.space_status)
}

// -------------------------------------------------------------------

// Request

// required .Header header = 1;
inline bool Request::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_header() {
  if (header_ != NULL) header_->::Header::Clear();
  clear_has_header();
}
inline const ::Header& Request::header() const {
  // @@protoc_insertion_point(field_get:Request.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::Header* Request::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::Header;
  // @@protoc_insertion_point(field_mutable:Request.header)
  return header_;
}
inline ::Header* Request::release_header() {
  clear_has_header();
  ::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Request::set_allocated_header(::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:Request.header)
}

// required .Payload body = 2;
inline bool Request::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_body() {
  if (body_ != NULL) body_->::Payload::Clear();
  clear_has_body();
}
inline const ::Payload& Request::body() const {
  // @@protoc_insertion_point(field_get:Request.body)
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::Payload* Request::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::Payload;
  // @@protoc_insertion_point(field_mutable:Request.body)
  return body_;
}
inline ::Payload* Request::release_body() {
  clear_has_body();
  ::Payload* temp = body_;
  body_ = NULL;
  return temp;
}
inline void Request::set_allocated_body(::Payload* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
  // @@protoc_insertion_point(field_set_allocated:Request.body)
}

// -------------------------------------------------------------------

// Heartbeat

// required int64 time_ref = 2;
inline bool Heartbeat::has_time_ref() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Heartbeat::set_has_time_ref() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Heartbeat::clear_has_time_ref() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Heartbeat::clear_time_ref() {
  time_ref_ = GOOGLE_LONGLONG(0);
  clear_has_time_ref();
}
inline ::google::protobuf::int64 Heartbeat::time_ref() const {
  // @@protoc_insertion_point(field_get:Heartbeat.time_ref)
  return time_ref_;
}
inline void Heartbeat::set_time_ref(::google::protobuf::int64 value) {
  set_has_time_ref();
  time_ref_ = value;
  // @@protoc_insertion_point(field_set:Heartbeat.time_ref)
}

// -------------------------------------------------------------------

// Network

// required int32 from_node_id = 1;
inline bool Network::has_from_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Network::set_has_from_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Network::clear_has_from_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Network::clear_from_node_id() {
  from_node_id_ = 0;
  clear_has_from_node_id();
}
inline ::google::protobuf::int32 Network::from_node_id() const {
  // @@protoc_insertion_point(field_get:Network.from_node_id)
  return from_node_id_;
}
inline void Network::set_from_node_id(::google::protobuf::int32 value) {
  set_has_from_node_id();
  from_node_id_ = value;
  // @@protoc_insertion_point(field_set:Network.from_node_id)
}

// required int32 to_node_id = 2;
inline bool Network::has_to_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Network::set_has_to_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Network::clear_has_to_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Network::clear_to_node_id() {
  to_node_id_ = 0;
  clear_has_to_node_id();
}
inline ::google::protobuf::int32 Network::to_node_id() const {
  // @@protoc_insertion_point(field_get:Network.to_node_id)
  return to_node_id_;
}
inline void Network::set_to_node_id(::google::protobuf::int32 value) {
  set_has_to_node_id();
  to_node_id_ = value;
  // @@protoc_insertion_point(field_set:Network.to_node_id)
}

// required .Network.NetworkAction action = 3;
inline bool Network::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Network::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Network::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Network::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::Network_NetworkAction Network::action() const {
  // @@protoc_insertion_point(field_get:Network.action)
  return static_cast< ::Network_NetworkAction >(action_);
}
inline void Network::set_action(::Network_NetworkAction value) {
  assert(::Network_NetworkAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:Network.action)
}

// -------------------------------------------------------------------

// LeaderElection

// required string elect_id = 2;
inline bool LeaderElection::has_elect_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LeaderElection::set_has_elect_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LeaderElection::clear_has_elect_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LeaderElection::clear_elect_id() {
  if (elect_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    elect_id_->clear();
  }
  clear_has_elect_id();
}
inline const ::std::string& LeaderElection::elect_id() const {
  // @@protoc_insertion_point(field_get:LeaderElection.elect_id)
  return *elect_id_;
}
inline void LeaderElection::set_elect_id(const ::std::string& value) {
  set_has_elect_id();
  if (elect_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    elect_id_ = new ::std::string;
  }
  elect_id_->assign(value);
  // @@protoc_insertion_point(field_set:LeaderElection.elect_id)
}
inline void LeaderElection::set_elect_id(const char* value) {
  set_has_elect_id();
  if (elect_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    elect_id_ = new ::std::string;
  }
  elect_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:LeaderElection.elect_id)
}
inline void LeaderElection::set_elect_id(const char* value, size_t size) {
  set_has_elect_id();
  if (elect_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    elect_id_ = new ::std::string;
  }
  elect_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LeaderElection.elect_id)
}
inline ::std::string* LeaderElection::mutable_elect_id() {
  set_has_elect_id();
  if (elect_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    elect_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LeaderElection.elect_id)
  return elect_id_;
}
inline ::std::string* LeaderElection::release_elect_id() {
  clear_has_elect_id();
  if (elect_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = elect_id_;
    elect_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LeaderElection::set_allocated_elect_id(::std::string* elect_id) {
  if (elect_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete elect_id_;
  }
  if (elect_id) {
    set_has_elect_id();
    elect_id_ = elect_id;
  } else {
    clear_has_elect_id();
    elect_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LeaderElection.elect_id)
}

// required int32 candidate_id = 3;
inline bool LeaderElection::has_candidate_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LeaderElection::set_has_candidate_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LeaderElection::clear_has_candidate_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LeaderElection::clear_candidate_id() {
  candidate_id_ = 0;
  clear_has_candidate_id();
}
inline ::google::protobuf::int32 LeaderElection::candidate_id() const {
  // @@protoc_insertion_point(field_get:LeaderElection.candidate_id)
  return candidate_id_;
}
inline void LeaderElection::set_candidate_id(::google::protobuf::int32 value) {
  set_has_candidate_id();
  candidate_id_ = value;
  // @@protoc_insertion_point(field_set:LeaderElection.candidate_id)
}

// optional string desc = 4;
inline bool LeaderElection::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LeaderElection::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LeaderElection::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LeaderElection::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& LeaderElection::desc() const {
  // @@protoc_insertion_point(field_get:LeaderElection.desc)
  return *desc_;
}
inline void LeaderElection::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:LeaderElection.desc)
}
inline void LeaderElection::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:LeaderElection.desc)
}
inline void LeaderElection::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LeaderElection.desc)
}
inline ::std::string* LeaderElection::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LeaderElection.desc)
  return desc_;
}
inline ::std::string* LeaderElection::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LeaderElection::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LeaderElection.desc)
}

// required .LeaderElection.ElectAction action = 5;
inline bool LeaderElection::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LeaderElection::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LeaderElection::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LeaderElection::clear_action() {
  action_ = 1;
  clear_has_action();
}
inline ::LeaderElection_ElectAction LeaderElection::action() const {
  // @@protoc_insertion_point(field_get:LeaderElection.action)
  return static_cast< ::LeaderElection_ElectAction >(action_);
}
inline void LeaderElection::set_action(::LeaderElection_ElectAction value) {
  assert(::LeaderElection_ElectAction_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:LeaderElection.action)
}

// optional int64 expires = 6 [default = -1];
inline bool LeaderElection::has_expires() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LeaderElection::set_has_expires() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LeaderElection::clear_has_expires() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LeaderElection::clear_expires() {
  expires_ = GOOGLE_LONGLONG(-1);
  clear_has_expires();
}
inline ::google::protobuf::int64 LeaderElection::expires() const {
  // @@protoc_insertion_point(field_get:LeaderElection.expires)
  return expires_;
}
inline void LeaderElection::set_expires(::google::protobuf::int64 value) {
  set_has_expires();
  expires_ = value;
  // @@protoc_insertion_point(field_set:LeaderElection.expires)
}

// optional int32 hops = 7 [default = -1];
inline bool LeaderElection::has_hops() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LeaderElection::set_has_hops() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LeaderElection::clear_has_hops() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LeaderElection::clear_hops() {
  hops_ = -1;
  clear_has_hops();
}
inline ::google::protobuf::int32 LeaderElection::hops() const {
  // @@protoc_insertion_point(field_get:LeaderElection.hops)
  return hops_;
}
inline void LeaderElection::set_hops(::google::protobuf::int32 value) {
  set_has_hops();
  hops_ = value;
  // @@protoc_insertion_point(field_set:LeaderElection.hops)
}

// -------------------------------------------------------------------

// VotingBallot

// required string ballot_id = 1;
inline bool VotingBallot::has_ballot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VotingBallot::set_has_ballot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VotingBallot::clear_has_ballot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VotingBallot::clear_ballot_id() {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_->clear();
  }
  clear_has_ballot_id();
}
inline const ::std::string& VotingBallot::ballot_id() const {
  // @@protoc_insertion_point(field_get:VotingBallot.ballot_id)
  return *ballot_id_;
}
inline void VotingBallot::set_ballot_id(const ::std::string& value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set:VotingBallot.ballot_id)
}
inline void VotingBallot::set_ballot_id(const char* value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:VotingBallot.ballot_id)
}
inline void VotingBallot::set_ballot_id(const char* value, size_t size) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VotingBallot.ballot_id)
}
inline ::std::string* VotingBallot::mutable_ballot_id() {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VotingBallot.ballot_id)
  return ballot_id_;
}
inline ::std::string* VotingBallot::release_ballot_id() {
  clear_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ballot_id_;
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VotingBallot::set_allocated_ballot_id(::std::string* ballot_id) {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ballot_id_;
  }
  if (ballot_id) {
    set_has_ballot_id();
    ballot_id_ = ballot_id;
  } else {
    clear_has_ballot_id();
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VotingBallot.ballot_id)
}

// required string desc = 2;
inline bool VotingBallot::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VotingBallot::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VotingBallot::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VotingBallot::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& VotingBallot::desc() const {
  // @@protoc_insertion_point(field_get:VotingBallot.desc)
  return *desc_;
}
inline void VotingBallot::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:VotingBallot.desc)
}
inline void VotingBallot::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:VotingBallot.desc)
}
inline void VotingBallot::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VotingBallot.desc)
}
inline ::std::string* VotingBallot::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VotingBallot.desc)
  return desc_;
}
inline ::std::string* VotingBallot::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VotingBallot::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VotingBallot.desc)
}

// required .VotingBallot.BallotType ballot_format = 3;
inline bool VotingBallot::has_ballot_format() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VotingBallot::set_has_ballot_format() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VotingBallot::clear_has_ballot_format() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VotingBallot::clear_ballot_format() {
  ballot_format_ = 1;
  clear_has_ballot_format();
}
inline ::VotingBallot_BallotType VotingBallot::ballot_format() const {
  // @@protoc_insertion_point(field_get:VotingBallot.ballot_format)
  return static_cast< ::VotingBallot_BallotType >(ballot_format_);
}
inline void VotingBallot::set_ballot_format(::VotingBallot_BallotType value) {
  assert(::VotingBallot_BallotType_IsValid(value));
  set_has_ballot_format();
  ballot_format_ = value;
  // @@protoc_insertion_point(field_set:VotingBallot.ballot_format)
}

// optional int64 expires_sec = 6;
inline bool VotingBallot::has_expires_sec() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VotingBallot::set_has_expires_sec() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VotingBallot::clear_has_expires_sec() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VotingBallot::clear_expires_sec() {
  expires_sec_ = GOOGLE_LONGLONG(0);
  clear_has_expires_sec();
}
inline ::google::protobuf::int64 VotingBallot::expires_sec() const {
  // @@protoc_insertion_point(field_get:VotingBallot.expires_sec)
  return expires_sec_;
}
inline void VotingBallot::set_expires_sec(::google::protobuf::int64 value) {
  set_has_expires_sec();
  expires_sec_ = value;
  // @@protoc_insertion_point(field_set:VotingBallot.expires_sec)
}

// optional int32 margin_to_win = 7;
inline bool VotingBallot::has_margin_to_win() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VotingBallot::set_has_margin_to_win() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VotingBallot::clear_has_margin_to_win() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VotingBallot::clear_margin_to_win() {
  margin_to_win_ = 0;
  clear_has_margin_to_win();
}
inline ::google::protobuf::int32 VotingBallot::margin_to_win() const {
  // @@protoc_insertion_point(field_get:VotingBallot.margin_to_win)
  return margin_to_win_;
}
inline void VotingBallot::set_margin_to_win(::google::protobuf::int32 value) {
  set_has_margin_to_win();
  margin_to_win_ = value;
  // @@protoc_insertion_point(field_set:VotingBallot.margin_to_win)
}

// optional int32 max_hops = 8 [default = -1];
inline bool VotingBallot::has_max_hops() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VotingBallot::set_has_max_hops() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VotingBallot::clear_has_max_hops() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VotingBallot::clear_max_hops() {
  max_hops_ = -1;
  clear_has_max_hops();
}
inline ::google::protobuf::int32 VotingBallot::max_hops() const {
  // @@protoc_insertion_point(field_get:VotingBallot.max_hops)
  return max_hops_;
}
inline void VotingBallot::set_max_hops(::google::protobuf::int32 value) {
  set_has_max_hops();
  max_hops_ = value;
  // @@protoc_insertion_point(field_set:VotingBallot.max_hops)
}

// -------------------------------------------------------------------

// VotingCast

// required string voter = 1;
inline bool VotingCast::has_voter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VotingCast::set_has_voter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VotingCast::clear_has_voter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VotingCast::clear_voter() {
  if (voter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voter_->clear();
  }
  clear_has_voter();
}
inline const ::std::string& VotingCast::voter() const {
  // @@protoc_insertion_point(field_get:VotingCast.voter)
  return *voter_;
}
inline void VotingCast::set_voter(const ::std::string& value) {
  set_has_voter();
  if (voter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voter_ = new ::std::string;
  }
  voter_->assign(value);
  // @@protoc_insertion_point(field_set:VotingCast.voter)
}
inline void VotingCast::set_voter(const char* value) {
  set_has_voter();
  if (voter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voter_ = new ::std::string;
  }
  voter_->assign(value);
  // @@protoc_insertion_point(field_set_char:VotingCast.voter)
}
inline void VotingCast::set_voter(const char* value, size_t size) {
  set_has_voter();
  if (voter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voter_ = new ::std::string;
  }
  voter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VotingCast.voter)
}
inline ::std::string* VotingCast::mutable_voter() {
  set_has_voter();
  if (voter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    voter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VotingCast.voter)
  return voter_;
}
inline ::std::string* VotingCast::release_voter() {
  clear_has_voter();
  if (voter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = voter_;
    voter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VotingCast::set_allocated_voter(::std::string* voter) {
  if (voter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete voter_;
  }
  if (voter) {
    set_has_voter();
    voter_ = voter;
  } else {
    clear_has_voter();
    voter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VotingCast.voter)
}

// required string ballot_id = 2;
inline bool VotingCast::has_ballot_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VotingCast::set_has_ballot_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VotingCast::clear_has_ballot_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VotingCast::clear_ballot_id() {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_->clear();
  }
  clear_has_ballot_id();
}
inline const ::std::string& VotingCast::ballot_id() const {
  // @@protoc_insertion_point(field_get:VotingCast.ballot_id)
  return *ballot_id_;
}
inline void VotingCast::set_ballot_id(const ::std::string& value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set:VotingCast.ballot_id)
}
inline void VotingCast::set_ballot_id(const char* value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:VotingCast.ballot_id)
}
inline void VotingCast::set_ballot_id(const char* value, size_t size) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VotingCast.ballot_id)
}
inline ::std::string* VotingCast::mutable_ballot_id() {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VotingCast.ballot_id)
  return ballot_id_;
}
inline ::std::string* VotingCast::release_ballot_id() {
  clear_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ballot_id_;
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VotingCast::set_allocated_ballot_id(::std::string* ballot_id) {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ballot_id_;
  }
  if (ballot_id) {
    set_has_ballot_id();
    ballot_id_ = ballot_id;
  } else {
    clear_has_ballot_id();
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VotingCast.ballot_id)
}

// optional int32 candidate = 10;
inline bool VotingCast::has_candidate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VotingCast::set_has_candidate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VotingCast::clear_has_candidate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VotingCast::clear_candidate() {
  candidate_ = 0;
  clear_has_candidate();
}
inline ::google::protobuf::int32 VotingCast::candidate() const {
  // @@protoc_insertion_point(field_get:VotingCast.candidate)
  return candidate_;
}
inline void VotingCast::set_candidate(::google::protobuf::int32 value) {
  set_has_candidate();
  candidate_ = value;
  // @@protoc_insertion_point(field_set:VotingCast.candidate)
}

// optional int32 rank = 11;
inline bool VotingCast::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VotingCast::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VotingCast::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VotingCast::clear_rank() {
  rank_ = 0;
  clear_has_rank();
}
inline ::google::protobuf::int32 VotingCast::rank() const {
  // @@protoc_insertion_point(field_get:VotingCast.rank)
  return rank_;
}
inline void VotingCast::set_rank(::google::protobuf::int32 value) {
  set_has_rank();
  rank_ = value;
  // @@protoc_insertion_point(field_set:VotingCast.rank)
}

// -------------------------------------------------------------------

// VotingStatus

// required string ballot_id = 1;
inline bool VotingStatus::has_ballot_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VotingStatus::set_has_ballot_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VotingStatus::clear_has_ballot_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VotingStatus::clear_ballot_id() {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_->clear();
  }
  clear_has_ballot_id();
}
inline const ::std::string& VotingStatus::ballot_id() const {
  // @@protoc_insertion_point(field_get:VotingStatus.ballot_id)
  return *ballot_id_;
}
inline void VotingStatus::set_ballot_id(const ::std::string& value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set:VotingStatus.ballot_id)
}
inline void VotingStatus::set_ballot_id(const char* value) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:VotingStatus.ballot_id)
}
inline void VotingStatus::set_ballot_id(const char* value, size_t size) {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  ballot_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:VotingStatus.ballot_id)
}
inline ::std::string* VotingStatus::mutable_ballot_id() {
  set_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    ballot_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:VotingStatus.ballot_id)
  return ballot_id_;
}
inline ::std::string* VotingStatus::release_ballot_id() {
  clear_has_ballot_id();
  if (ballot_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = ballot_id_;
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void VotingStatus::set_allocated_ballot_id(::std::string* ballot_id) {
  if (ballot_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete ballot_id_;
  }
  if (ballot_id) {
    set_has_ballot_id();
    ballot_id_ = ballot_id;
  } else {
    clear_has_ballot_id();
    ballot_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:VotingStatus.ballot_id)
}

// required .VotingStatus.VoteStatus status = 2;
inline bool VotingStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VotingStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VotingStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VotingStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::VotingStatus_VoteStatus VotingStatus::status() const {
  // @@protoc_insertion_point(field_get:VotingStatus.status)
  return static_cast< ::VotingStatus_VoteStatus >(status_);
}
inline void VotingStatus::set_status(::VotingStatus_VoteStatus value) {
  assert(::VotingStatus_VoteStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:VotingStatus.status)
}

// optional int32 winner = 3;
inline bool VotingStatus::has_winner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VotingStatus::set_has_winner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VotingStatus::clear_has_winner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VotingStatus::clear_winner() {
  winner_ = 0;
  clear_has_winner();
}
inline ::google::protobuf::int32 VotingStatus::winner() const {
  // @@protoc_insertion_point(field_get:VotingStatus.winner)
  return winner_;
}
inline void VotingStatus::set_winner(::google::protobuf::int32 value) {
  set_has_winner();
  winner_ = value;
  // @@protoc_insertion_point(field_set:VotingStatus.winner)
}

// -------------------------------------------------------------------

// MgmtHeader

// required int32 originator = 2;
inline bool MgmtHeader::has_originator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MgmtHeader::set_has_originator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MgmtHeader::clear_has_originator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MgmtHeader::clear_originator() {
  originator_ = 0;
  clear_has_originator();
}
inline ::google::protobuf::int32 MgmtHeader::originator() const {
  // @@protoc_insertion_point(field_get:MgmtHeader.originator)
  return originator_;
}
inline void MgmtHeader::set_originator(::google::protobuf::int32 value) {
  set_has_originator();
  originator_ = value;
  // @@protoc_insertion_point(field_set:MgmtHeader.originator)
}

// optional int64 time = 4;
inline bool MgmtHeader::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MgmtHeader::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MgmtHeader::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MgmtHeader::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 MgmtHeader::time() const {
  // @@protoc_insertion_point(field_get:MgmtHeader.time)
  return time_;
}
inline void MgmtHeader::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:MgmtHeader.time)
}

// repeated .RoutingPath path = 7;
inline int MgmtHeader::path_size() const {
  return path_.size();
}
inline void MgmtHeader::clear_path() {
  path_.Clear();
}
inline const ::RoutingPath& MgmtHeader::path(int index) const {
  // @@protoc_insertion_point(field_get:MgmtHeader.path)
  return path_.Get(index);
}
inline ::RoutingPath* MgmtHeader::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:MgmtHeader.path)
  return path_.Mutable(index);
}
inline ::RoutingPath* MgmtHeader::add_path() {
  // @@protoc_insertion_point(field_add:MgmtHeader.path)
  return path_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RoutingPath >&
MgmtHeader::path() const {
  // @@protoc_insertion_point(field_list:MgmtHeader.path)
  return path_;
}
inline ::google::protobuf::RepeatedPtrField< ::RoutingPath >*
MgmtHeader::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:MgmtHeader.path)
  return &path_;
}

// optional int32 toNode = 8;
inline bool MgmtHeader::has_tonode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MgmtHeader::set_has_tonode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MgmtHeader::clear_has_tonode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MgmtHeader::clear_tonode() {
  tonode_ = 0;
  clear_has_tonode();
}
inline ::google::protobuf::int32 MgmtHeader::tonode() const {
  // @@protoc_insertion_point(field_get:MgmtHeader.toNode)
  return tonode_;
}
inline void MgmtHeader::set_tonode(::google::protobuf::int32 value) {
  set_has_tonode();
  tonode_ = value;
  // @@protoc_insertion_point(field_set:MgmtHeader.toNode)
}

// -------------------------------------------------------------------

// Management

// required .MgmtHeader header = 1;
inline bool Management::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Management::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Management::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Management::clear_header() {
  if (header_ != NULL) header_->::MgmtHeader::Clear();
  clear_has_header();
}
inline const ::MgmtHeader& Management::header() const {
  // @@protoc_insertion_point(field_get:Management.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::MgmtHeader* Management::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::MgmtHeader;
  // @@protoc_insertion_point(field_mutable:Management.header)
  return header_;
}
inline ::MgmtHeader* Management::release_header() {
  clear_has_header();
  ::MgmtHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Management::set_allocated_header(::MgmtHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.header)
}

// optional .Network graph = 2;
inline bool Management::has_graph() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Management::set_has_graph() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Management::clear_has_graph() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Management::clear_graph() {
  if (graph_ != NULL) graph_->::Network::Clear();
  clear_has_graph();
}
inline const ::Network& Management::graph() const {
  // @@protoc_insertion_point(field_get:Management.graph)
  return graph_ != NULL ? *graph_ : *default_instance_->graph_;
}
inline ::Network* Management::mutable_graph() {
  set_has_graph();
  if (graph_ == NULL) graph_ = new ::Network;
  // @@protoc_insertion_point(field_mutable:Management.graph)
  return graph_;
}
inline ::Network* Management::release_graph() {
  clear_has_graph();
  ::Network* temp = graph_;
  graph_ = NULL;
  return temp;
}
inline void Management::set_allocated_graph(::Network* graph) {
  delete graph_;
  graph_ = graph;
  if (graph) {
    set_has_graph();
  } else {
    clear_has_graph();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.graph)
}

// optional .Heartbeat beat = 3;
inline bool Management::has_beat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Management::set_has_beat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Management::clear_has_beat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Management::clear_beat() {
  if (beat_ != NULL) beat_->::Heartbeat::Clear();
  clear_has_beat();
}
inline const ::Heartbeat& Management::beat() const {
  // @@protoc_insertion_point(field_get:Management.beat)
  return beat_ != NULL ? *beat_ : *default_instance_->beat_;
}
inline ::Heartbeat* Management::mutable_beat() {
  set_has_beat();
  if (beat_ == NULL) beat_ = new ::Heartbeat;
  // @@protoc_insertion_point(field_mutable:Management.beat)
  return beat_;
}
inline ::Heartbeat* Management::release_beat() {
  clear_has_beat();
  ::Heartbeat* temp = beat_;
  beat_ = NULL;
  return temp;
}
inline void Management::set_allocated_beat(::Heartbeat* beat) {
  delete beat_;
  beat_ = beat;
  if (beat) {
    set_has_beat();
  } else {
    clear_has_beat();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.beat)
}

// optional .LeaderElection election = 4;
inline bool Management::has_election() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Management::set_has_election() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Management::clear_has_election() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Management::clear_election() {
  if (election_ != NULL) election_->::LeaderElection::Clear();
  clear_has_election();
}
inline const ::LeaderElection& Management::election() const {
  // @@protoc_insertion_point(field_get:Management.election)
  return election_ != NULL ? *election_ : *default_instance_->election_;
}
inline ::LeaderElection* Management::mutable_election() {
  set_has_election();
  if (election_ == NULL) election_ = new ::LeaderElection;
  // @@protoc_insertion_point(field_mutable:Management.election)
  return election_;
}
inline ::LeaderElection* Management::release_election() {
  clear_has_election();
  ::LeaderElection* temp = election_;
  election_ = NULL;
  return temp;
}
inline void Management::set_allocated_election(::LeaderElection* election) {
  delete election_;
  election_ = election;
  if (election) {
    set_has_election();
  } else {
    clear_has_election();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.election)
}

// optional .JobProposal job_propose = 5;
inline bool Management::has_job_propose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Management::set_has_job_propose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Management::clear_has_job_propose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Management::clear_job_propose() {
  if (job_propose_ != NULL) job_propose_->::JobProposal::Clear();
  clear_has_job_propose();
}
inline const ::JobProposal& Management::job_propose() const {
  // @@protoc_insertion_point(field_get:Management.job_propose)
  return job_propose_ != NULL ? *job_propose_ : *default_instance_->job_propose_;
}
inline ::JobProposal* Management::mutable_job_propose() {
  set_has_job_propose();
  if (job_propose_ == NULL) job_propose_ = new ::JobProposal;
  // @@protoc_insertion_point(field_mutable:Management.job_propose)
  return job_propose_;
}
inline ::JobProposal* Management::release_job_propose() {
  clear_has_job_propose();
  ::JobProposal* temp = job_propose_;
  job_propose_ = NULL;
  return temp;
}
inline void Management::set_allocated_job_propose(::JobProposal* job_propose) {
  delete job_propose_;
  job_propose_ = job_propose;
  if (job_propose) {
    set_has_job_propose();
  } else {
    clear_has_job_propose();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.job_propose)
}

// optional .JobBid job_bid = 6;
inline bool Management::has_job_bid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Management::set_has_job_bid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Management::clear_has_job_bid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Management::clear_job_bid() {
  if (job_bid_ != NULL) job_bid_->::JobBid::Clear();
  clear_has_job_bid();
}
inline const ::JobBid& Management::job_bid() const {
  // @@protoc_insertion_point(field_get:Management.job_bid)
  return job_bid_ != NULL ? *job_bid_ : *default_instance_->job_bid_;
}
inline ::JobBid* Management::mutable_job_bid() {
  set_has_job_bid();
  if (job_bid_ == NULL) job_bid_ = new ::JobBid;
  // @@protoc_insertion_point(field_mutable:Management.job_bid)
  return job_bid_;
}
inline ::JobBid* Management::release_job_bid() {
  clear_has_job_bid();
  ::JobBid* temp = job_bid_;
  job_bid_ = NULL;
  return temp;
}
inline void Management::set_allocated_job_bid(::JobBid* job_bid) {
  delete job_bid_;
  job_bid_ = job_bid;
  if (job_bid) {
    set_has_job_bid();
  } else {
    clear_has_job_bid();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.job_bid)
}

// optional .VotingBallot vote_declare = 7;
inline bool Management::has_vote_declare() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Management::set_has_vote_declare() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Management::clear_has_vote_declare() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Management::clear_vote_declare() {
  if (vote_declare_ != NULL) vote_declare_->::VotingBallot::Clear();
  clear_has_vote_declare();
}
inline const ::VotingBallot& Management::vote_declare() const {
  // @@protoc_insertion_point(field_get:Management.vote_declare)
  return vote_declare_ != NULL ? *vote_declare_ : *default_instance_->vote_declare_;
}
inline ::VotingBallot* Management::mutable_vote_declare() {
  set_has_vote_declare();
  if (vote_declare_ == NULL) vote_declare_ = new ::VotingBallot;
  // @@protoc_insertion_point(field_mutable:Management.vote_declare)
  return vote_declare_;
}
inline ::VotingBallot* Management::release_vote_declare() {
  clear_has_vote_declare();
  ::VotingBallot* temp = vote_declare_;
  vote_declare_ = NULL;
  return temp;
}
inline void Management::set_allocated_vote_declare(::VotingBallot* vote_declare) {
  delete vote_declare_;
  vote_declare_ = vote_declare;
  if (vote_declare) {
    set_has_vote_declare();
  } else {
    clear_has_vote_declare();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.vote_declare)
}

// optional .VotingCast vote_cast = 8;
inline bool Management::has_vote_cast() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Management::set_has_vote_cast() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Management::clear_has_vote_cast() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Management::clear_vote_cast() {
  if (vote_cast_ != NULL) vote_cast_->::VotingCast::Clear();
  clear_has_vote_cast();
}
inline const ::VotingCast& Management::vote_cast() const {
  // @@protoc_insertion_point(field_get:Management.vote_cast)
  return vote_cast_ != NULL ? *vote_cast_ : *default_instance_->vote_cast_;
}
inline ::VotingCast* Management::mutable_vote_cast() {
  set_has_vote_cast();
  if (vote_cast_ == NULL) vote_cast_ = new ::VotingCast;
  // @@protoc_insertion_point(field_mutable:Management.vote_cast)
  return vote_cast_;
}
inline ::VotingCast* Management::release_vote_cast() {
  clear_has_vote_cast();
  ::VotingCast* temp = vote_cast_;
  vote_cast_ = NULL;
  return temp;
}
inline void Management::set_allocated_vote_cast(::VotingCast* vote_cast) {
  delete vote_cast_;
  vote_cast_ = vote_cast;
  if (vote_cast) {
    set_has_vote_cast();
  } else {
    clear_has_vote_cast();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.vote_cast)
}

// optional .VotingStatus vote_status = 9;
inline bool Management::has_vote_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Management::set_has_vote_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Management::clear_has_vote_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Management::clear_vote_status() {
  if (vote_status_ != NULL) vote_status_->::VotingStatus::Clear();
  clear_has_vote_status();
}
inline const ::VotingStatus& Management::vote_status() const {
  // @@protoc_insertion_point(field_get:Management.vote_status)
  return vote_status_ != NULL ? *vote_status_ : *default_instance_->vote_status_;
}
inline ::VotingStatus* Management::mutable_vote_status() {
  set_has_vote_status();
  if (vote_status_ == NULL) vote_status_ = new ::VotingStatus;
  // @@protoc_insertion_point(field_mutable:Management.vote_status)
  return vote_status_;
}
inline ::VotingStatus* Management::release_vote_status() {
  clear_has_vote_status();
  ::VotingStatus* temp = vote_status_;
  vote_status_ = NULL;
  return temp;
}
inline void Management::set_allocated_vote_status(::VotingStatus* vote_status) {
  delete vote_status_;
  vote_status_ = vote_status;
  if (vote_status) {
    set_has_vote_status();
  } else {
    clear_has_vote_status();
  }
  // @@protoc_insertion_point(field_set_allocated:Management.vote_status)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::NameValueSet_NodeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NameValueSet_NodeType>() {
  return ::NameValueSet_NodeType_descriptor();
}
template <> struct is_proto_enum< ::JobDesc_JobCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobDesc_JobCode>() {
  return ::JobDesc_JobCode_descriptor();
}
template <> struct is_proto_enum< ::NameSpaceOperation_SpaceAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::NameSpaceOperation_SpaceAction>() {
  return ::NameSpaceOperation_SpaceAction_descriptor();
}
template <> struct is_proto_enum< ::JobOperation_JobAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::JobOperation_JobAction>() {
  return ::JobOperation_JobAction_descriptor();
}
template <> struct is_proto_enum< ::Header_Routing> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Header_Routing>() {
  return ::Header_Routing_descriptor();
}
template <> struct is_proto_enum< ::Network_NetworkAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Network_NetworkAction>() {
  return ::Network_NetworkAction_descriptor();
}
template <> struct is_proto_enum< ::LeaderElection_ElectAction> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LeaderElection_ElectAction>() {
  return ::LeaderElection_ElectAction_descriptor();
}
template <> struct is_proto_enum< ::VotingBallot_BallotType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VotingBallot_BallotType>() {
  return ::VotingBallot_BallotType_descriptor();
}
template <> struct is_proto_enum< ::VotingStatus_VoteStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::VotingStatus_VoteStatus>() {
  return ::VotingStatus_VoteStatus_descriptor();
}
template <> struct is_proto_enum< ::PokeStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PokeStatus>() {
  return ::PokeStatus_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_comm_2eproto__INCLUDED
